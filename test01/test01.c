//-------------------------------------------------------------------------------------------------
// Winapi and core stuff
//-------------------------------------------------------------------------------------------------
#define NULL ((void *)0)
#ifdef _DEBUG
#define assert(expression) if (!(expression)) { __debugbreak(); }
#else
#define assert(expression)
#endif
#define restrict __restrict
typedef unsigned char U8;
typedef unsigned short U16;
typedef unsigned int U32;
typedef unsigned long long U64;
typedef char S8;
typedef short S16;
typedef int S32;
typedef int B32;
typedef long long S64;
typedef float F32;
typedef double F64;

#define VHR(r) if ((r) < 0) { assert(0); }
#define SAFE_RELEASE(o) if ((o)) { IUnknown_Release((o)); (o) = NULL; }

#define TRUE 1
#define FALSE 0
#define PM_REMOVE 0x0001
#define WM_QUIT 0x0012
#define WM_DESTROY 0x0002
#define WM_KEYDOWN 0x0100
#define VK_ESCAPE 0x001b
#define VK_CONTROL 0x11
#define WS_OVERLAPPED 0x00000000L
#define WS_VISIBLE 0x10000000L
#define WS_CAPTION 0x00C00000L
#define WS_SYSMENU 0x00080000L
#define WS_MINIMIZEBOX 0x00020000L
#define CW_USEDEFAULT ((U32)0x80000000)
#define MAKEINTRESOURCE(i) ((char *)((U64)((U16)(i))))
#define IDC_ARROW MAKEINTRESOURCE(32512)
#define PFD_TYPE_RGBA 0
#define PFD_DOUBLEBUFFER 0x00000001
#define PFD_DRAW_TO_WINDOW 0x00000004
#define PFD_SUPPORT_OPENGL 0x00000020
#define GENERIC_READ 0x80000000
#define OPEN_EXISTING 3
#define MEM_COMMIT 0x1000
#define MEM_RESERVE 0x2000
#define MEM_RELEASE 0x8000
#define PAGE_READWRITE 0x04
#define INFINITE 0xFFFFFFFF
#define STANDARD_RIGHTS_REQUIRED 0x000F0000L
#define SYNCHRONIZE 0x00100000L
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)

typedef struct IUnknown IUnknown;
typedef struct POINT { S32 x, y; } POINT;
typedef struct MSG { void *hwnd; U32 message; U64 wParam; S64 lParam; U32 time; POINT pt; } MSG;
typedef struct GUID { U32 Data1; U16 Data2; U16 Data3; U8 Data4[8]; } GUID;
typedef struct SECURITY_ATTRIBUTES { U32 nLength; void *lpSecurityDescriptor; S32 bInheritHandle; } SECURITY_ATTRIBUTES;
typedef struct RECT { S32 left; S32 top; S32 right; S32 bottom; } RECT;
typedef struct WNDCLASS { U32 style; void *lpfnWndProc; S32 cbClsExtra; S32 cbWndExtra; void *hInstance; void *hIcon; void *hCursor; void *hbrBackground; const char *lpszMenuName; const char *lpszClassName; } WNDCLASS;

typedef struct IUnknownVt {
    S32 (__stdcall *QueryInterface)(IUnknown *, const GUID *, void **);
    U32 (__stdcall *AddRef)(IUnknown *);
    U32 (__stdcall *Release)(IUnknown *);
} IUnknownVt; struct IUnknown { IUnknownVt* vt; };

void *__stdcall LoadLibraryA(const char *);
void *__stdcall GetProcAddress(void *, const char *);

S32 _fltused;

static void (__stdcall *OutputDebugString)(const char *);
static B32 (__stdcall *QueryPerformanceCounter)(S64 *);
static B32 (__stdcall *QueryPerformanceFrequency)(S64 *);
static void *(__stdcall *VirtualAlloc)(void *, U64, U32, U32);
static B32 (__stdcall *VirtualFree)(void *, U64, U32);
static void (__stdcall *ExitProcess)(U32);
static void *(__stdcall *CreateFile)(const char *, U32, U32, SECURITY_ATTRIBUTES *, U32, U32, void *);
static B32 (__stdcall *ReadFile)(void *, void *, U32, U32 *, void *);
static U32 (__stdcall *GetFileSize)(void *, U32 *);
static B32 (__stdcall *CloseHandle)(void *);
static void *(__stdcall *GetModuleHandle)(const char *);
static void (__stdcall *Sleep)(U32);
static void *(__stdcall *HeapAlloc)(void *, U32, U64);
static B32 (__stdcall *HeapFree)(void *, U32, void *);
static void *(__stdcall *HeapReAlloc)(void *, U32, void *, U64);
static void *(__stdcall *GetProcessHeap)(void);
static void *(__stdcall *CreateEventEx)(SECURITY_ATTRIBUTES *, const char *, U32, U32);
static U32 (__stdcall *WaitForSingleObject)(void *, U32);

static B32 (__stdcall *PeekMessage)(MSG *, void *, U32, U32, U32);
static S64 (__stdcall *DispatchMessage)(const MSG *);
static void (__stdcall *PostQuitMessage)(S32);
static S64 (__stdcall *DefWindowProc)(void *, U32, U64, S64);
static void *(__stdcall *LoadCursor)(void *, const char *);
static S16 (__stdcall *RegisterClass)(const WNDCLASS *);
static void *(__stdcall *CreateWindowEx)(U32, const char *, const char *, U32, S32, S32, S32, S32, void *, void *, void *, void *);
static B32 (__stdcall *AdjustWindowRect)(RECT *, U32, S32);
static B32 (__cdecl *wsprintf)(char *, const char *, ...);
static B32 (__stdcall *SetWindowText)(void *, const char *);
static B32 (__stdcall *SetProcessDPIAware)(void);
static void *(__stdcall *GetDC)(void *);
static B32 (__stdcall *MessageBox)(void *, const char *, const char *, U32);
static B32 (__stdcall *GetClientRect)(void *, RECT *);

void *memset(void *dest, S32 value, U64 count);
#pragma intrinsic(memset)

#pragma function(memset)
void *memset(void *dest, S32 value, U64 count)
{
    __stosb((U8 *)dest, (U8)value, count);
    return dest;
}
//-------------------------------------------------------------------------------------------------
// DXGI
//-------------------------------------------------------------------------------------------------
#define DXGI_USAGE_RENDER_TARGET_OUTPUT 0x00000020UL

typedef struct IDXGIFactory IDXGIFactory;
typedef struct IDXGISwapChain IDXGISwapChain;
typedef struct IDXGISwapChain3 IDXGISwapChain3;
typedef struct IDXGIAdapter IDXGIAdapter;
typedef struct IDXGIOutput IDXGIOutput;
typedef struct DXGI_SWAP_CHAIN_DESC1 DXGI_SWAP_CHAIN_DESC1;
typedef struct DXGI_SWAP_CHAIN_FULLSCREEN_DESC DXGI_SWAP_CHAIN_FULLSCREEN_DESC;
typedef struct DXGI_MATRIX_3X2_F DXGI_MATRIX_3X2_F;
typedef struct DXGI_PRESENT_PARAMETERS DXGI_PRESENT_PARAMETERS;

typedef enum DXGI_SWAP_EFFECT { DXGI_SWAP_EFFECT_DISCARD = 0, DXGI_SWAP_EFFECT_SEQUENTIAL = 1, DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL = 3, DXGI_SWAP_EFFECT_FLIP_DISCARD = 4 } DXGI_SWAP_EFFECT;
typedef enum DXGI_FORMAT { DXGI_FORMAT_UNKNOWN = 0, DXGI_FORMAT_R32G32B32A32_TYPELESS = 1, DXGI_FORMAT_R32G32B32A32_FLOAT = 2, DXGI_FORMAT_R32G32B32A32_UINT = 3, DXGI_FORMAT_R32G32B32A32_SINT = 4, DXGI_FORMAT_R32G32B32_TYPELESS = 5, DXGI_FORMAT_R32G32B32_FLOAT = 6, DXGI_FORMAT_R32G32B32_UINT = 7, DXGI_FORMAT_R32G32B32_SINT = 8, DXGI_FORMAT_R16G16B16A16_TYPELESS = 9, DXGI_FORMAT_R16G16B16A16_FLOAT = 10, DXGI_FORMAT_R16G16B16A16_UNORM = 11, DXGI_FORMAT_R16G16B16A16_UINT = 12, DXGI_FORMAT_R16G16B16A16_SNORM = 13, DXGI_FORMAT_R16G16B16A16_SINT = 14, DXGI_FORMAT_R32G32_TYPELESS = 15, DXGI_FORMAT_R32G32_FLOAT = 16, DXGI_FORMAT_R32G32_UINT = 17, DXGI_FORMAT_R32G32_SINT = 18, DXGI_FORMAT_R32G8X24_TYPELESS = 19, DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20, DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21, DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22, DXGI_FORMAT_R10G10B10A2_TYPELESS = 23, DXGI_FORMAT_R10G10B10A2_UNORM = 24, DXGI_FORMAT_R10G10B10A2_UINT = 25, DXGI_FORMAT_R11G11B10_FLOAT = 26, DXGI_FORMAT_R8G8B8A8_TYPELESS = 27, DXGI_FORMAT_R8G8B8A8_UNORM = 28, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29, DXGI_FORMAT_R8G8B8A8_UINT = 30, DXGI_FORMAT_R8G8B8A8_SNORM = 31, DXGI_FORMAT_R8G8B8A8_SINT = 32, DXGI_FORMAT_R16G16_TYPELESS = 33, DXGI_FORMAT_R16G16_FLOAT = 34, DXGI_FORMAT_R16G16_UNORM = 35, DXGI_FORMAT_R16G16_UINT = 36, DXGI_FORMAT_R16G16_SNORM = 37, DXGI_FORMAT_R16G16_SINT = 38, DXGI_FORMAT_R32_TYPELESS = 39, DXGI_FORMAT_D32_FLOAT = 40, DXGI_FORMAT_R32_FLOAT = 41, DXGI_FORMAT_R32_UINT = 42, DXGI_FORMAT_R32_SINT = 43, DXGI_FORMAT_R24G8_TYPELESS = 44, DXGI_FORMAT_D24_UNORM_S8_UINT = 45, DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46, DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47, DXGI_FORMAT_R8G8_TYPELESS = 48, DXGI_FORMAT_R8G8_UNORM = 49, DXGI_FORMAT_R8G8_UINT = 50, DXGI_FORMAT_R8G8_SNORM = 51, DXGI_FORMAT_R8G8_SINT = 52, DXGI_FORMAT_R16_TYPELESS = 53, DXGI_FORMAT_R16_FLOAT = 54, DXGI_FORMAT_D16_UNORM = 55, DXGI_FORMAT_R16_UNORM = 56, DXGI_FORMAT_R16_UINT = 57, DXGI_FORMAT_R16_SNORM = 58, DXGI_FORMAT_R16_SINT = 59, DXGI_FORMAT_R8_TYPELESS = 60, DXGI_FORMAT_R8_UNORM = 61, DXGI_FORMAT_R8_UINT = 62, DXGI_FORMAT_R8_SNORM = 63, DXGI_FORMAT_R8_SINT = 64, DXGI_FORMAT_A8_UNORM = 65, DXGI_FORMAT_R1_UNORM = 66, DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67, DXGI_FORMAT_R8G8_B8G8_UNORM = 68, DXGI_FORMAT_G8R8_G8B8_UNORM = 69, DXGI_FORMAT_BC1_TYPELESS = 70, DXGI_FORMAT_BC1_UNORM = 71, DXGI_FORMAT_BC1_UNORM_SRGB = 72, DXGI_FORMAT_BC2_TYPELESS = 73, DXGI_FORMAT_BC2_UNORM = 74, DXGI_FORMAT_BC2_UNORM_SRGB = 75, DXGI_FORMAT_BC3_TYPELESS = 76, DXGI_FORMAT_BC3_UNORM = 77, DXGI_FORMAT_BC3_UNORM_SRGB = 78, DXGI_FORMAT_BC4_TYPELESS = 79, DXGI_FORMAT_BC4_UNORM = 80, DXGI_FORMAT_BC4_SNORM = 81, DXGI_FORMAT_BC5_TYPELESS = 82, DXGI_FORMAT_BC5_UNORM = 83, DXGI_FORMAT_BC5_SNORM = 84, DXGI_FORMAT_B5G6R5_UNORM = 85, DXGI_FORMAT_B5G5R5A1_UNORM = 86, DXGI_FORMAT_B8G8R8A8_UNORM = 87, DXGI_FORMAT_B8G8R8X8_UNORM = 88, DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89, DXGI_FORMAT_B8G8R8A8_TYPELESS = 90, DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91, DXGI_FORMAT_B8G8R8X8_TYPELESS = 92, DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93, DXGI_FORMAT_BC6H_TYPELESS = 94, DXGI_FORMAT_BC6H_UF16 = 95, DXGI_FORMAT_BC6H_SF16 = 96, DXGI_FORMAT_BC7_TYPELESS = 97, DXGI_FORMAT_BC7_UNORM = 98, DXGI_FORMAT_BC7_UNORM_SRGB = 99, DXGI_FORMAT_AYUV = 100, DXGI_FORMAT_Y410 = 101, DXGI_FORMAT_Y416 = 102, DXGI_FORMAT_NV12 = 103, DXGI_FORMAT_P010 = 104, DXGI_FORMAT_P016 = 105, DXGI_FORMAT_420_OPAQUE = 106, DXGI_FORMAT_YUY2 = 107, DXGI_FORMAT_Y210 = 108, DXGI_FORMAT_Y216 = 109, DXGI_FORMAT_NV11 = 110, DXGI_FORMAT_AI44 = 111, DXGI_FORMAT_IA44 = 112, DXGI_FORMAT_P8 = 113, DXGI_FORMAT_A8P8 = 114, DXGI_FORMAT_B4G4R4A4_UNORM = 115, DXGI_FORMAT_P208 = 130, DXGI_FORMAT_V208 = 131, DXGI_FORMAT_V408 = 132, DXGI_FORMAT_FORCE_UINT = 0xffffffff } DXGI_FORMAT;
typedef enum DXGI_MODE_SCANLINE_ORDER { DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED = 0, DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE = 1, DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST = 2, DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST = 3 } DXGI_MODE_SCANLINE_ORDER;
typedef enum DXGI_MODE_SCALING { DXGI_MODE_SCALING_UNSPECIFIED = 0, DXGI_MODE_SCALING_CENTERED = 1, DXGI_MODE_SCALING_STRETCHED = 2 } DXGI_MODE_SCALING;
typedef enum DXGI_MODE_ROTATION { DXGI_MODE_ROTATION_UNSPECIFIED = 0, DXGI_MODE_ROTATION_IDENTITY = 1, DXGI_MODE_ROTATION_ROTATE90 = 2, DXGI_MODE_ROTATION_ROTATE180 = 3, DXGI_MODE_ROTATION_ROTATE270 = 4 } DXGI_MODE_ROTATION;
typedef enum DXGI_COLOR_SPACE_TYPE { DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709 = 0, DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709 = 1, DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P709 = 2, DXGI_COLOR_SPACE_RGB_STUDIO_G22_NONE_P2020 = 3, DXGI_COLOR_SPACE_RESERVED = 4, DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601 = 5, DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 = 6, DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601 = 7, DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 = 8, DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709 = 9, DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020 = 10, DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020 = 11, DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020 = 12, DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_LEFT_P2020 = 13, DXGI_COLOR_SPACE_RGB_STUDIO_G2084_NONE_P2020 = 14, DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_TOPLEFT_P2020 = 15, DXGI_COLOR_SPACE_YCBCR_STUDIO_G2084_TOPLEFT_P2020 = 16, DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P2020 = 17, DXGI_COLOR_SPACE_CUSTOM = 0xFFFFFFFF } DXGI_COLOR_SPACE_TYPE;

typedef U32 DXGI_USAGE;
typedef struct DXGI_SAMPLE_DESC { U32 Count; U32 Quality; } DXGI_SAMPLE_DESC;
typedef struct DXGI_RGBA { F32 Red; F32 Green; F32 Blue; F32 Alpha; } DXGI_RGBA;
typedef struct DXGI_RATIONAL { U32 Numerator; U32 Denominator; } DXGI_RATIONAL;
typedef struct DXGI_MODE_DESC { U32 Width; U32 Height; DXGI_RATIONAL RefreshRate; DXGI_FORMAT Format; DXGI_MODE_SCANLINE_ORDER ScanlineOrdering; DXGI_MODE_SCALING Scaling; } DXGI_MODE_DESC;
typedef struct DXGI_FRAME_STATISTICS { U32 PresentCount; U32 PresentRefreshCount; U32 SyncRefreshCount; S64 SyncQPCTime; S64 SyncGPUTime; } DXGI_FRAME_STATISTICS;
typedef struct DXGI_SWAP_CHAIN_DESC { DXGI_MODE_DESC BufferDesc; DXGI_SAMPLE_DESC SampleDesc; DXGI_USAGE BufferUsage; U32 BufferCount; void *OutputWindow; B32 Windowed; DXGI_SWAP_EFFECT SwapEffect; U32 Flags; } DXGI_SWAP_CHAIN_DESC;

typedef struct IDXGIFactoryVt {
    S32 (__stdcall *QueryInterface)(IDXGIFactory *, const GUID *, void **);
    U32 (__stdcall *AddRef)(IDXGIFactory *);
    U32 (__stdcall *Release)(IDXGIFactory *);
    S32 (__stdcall *SetPrivateData)(IDXGIFactory *, const GUID *, U32, const void *);
    S32 (__stdcall *SetPrivateDataInterface)(IDXGIFactory *, const GUID *, const IUnknown *);
    S32 (__stdcall *GetPrivateData)(IDXGIFactory *, const GUID *, U32 *, void *);
    S32 (__stdcall *GetParent)(IDXGIFactory *, const GUID *, void **);
    S32 (__stdcall *EnumAdapters)(IDXGIFactory *, U32, IDXGIAdapter **);
    S32 (__stdcall *MakeWindowAssociation)(IDXGIFactory *, void *, U32);
    S32 (__stdcall *GetWindowAssociation)(IDXGIFactory *, void **);
    S32 (__stdcall *CreateSwapChain)(IDXGIFactory *, IUnknown *, DXGI_SWAP_CHAIN_DESC *, IDXGISwapChain **);
    S32 (__stdcall *CreateSoftwareAdapter)(IDXGIFactory *self, void *module, IDXGIAdapter **);
} IDXGIFactoryVt; struct IDXGIFactory { const IDXGIFactoryVt *vt; };

typedef struct IDXGISwapChain3Vt {
    S32 (__stdcall *QueryInterface)(IDXGISwapChain3 *, const GUID *, void **);
    U32 (__stdcall *AddRef)(IDXGISwapChain3 *);
    U32 (__stdcall *Release)(IDXGISwapChain3 *);
    S32 (__stdcall *SetPrivateData)(IDXGISwapChain3 *, const GUID *, U32, const void *);
    S32 (__stdcall *SetPrivateDataInterface)(IDXGISwapChain3 *, const GUID *, const IUnknown *);
    S32 (__stdcall *GetPrivateData)(IDXGISwapChain3 *, const GUID *, U32 *, void *);
    S32 (__stdcall *GetParent)(IDXGISwapChain3 *, const GUID *, void **);
    S32 (__stdcall *GetDevice)(IDXGISwapChain3 *, const GUID *, void **);
    S32 (__stdcall *Present)(IDXGISwapChain3 *, U32, U32);
    S32 (__stdcall *GetBuffer)(IDXGISwapChain3 *, U32, const GUID *, void **);
    S32 (__stdcall *SetFullscreenState)(IDXGISwapChain3 *, S32, IDXGIOutput *);
    S32 (__stdcall *GetFullscreenState)(IDXGISwapChain3 *, S32 *, IDXGIOutput **);
    S32 (__stdcall *GetDesc)(IDXGISwapChain3 *, DXGI_SWAP_CHAIN_DESC *);
    S32 (__stdcall *ResizeBuffers)(IDXGISwapChain3 *, U32, U32, U32, DXGI_FORMAT, U32);
    S32 (__stdcall *ResizeTarget)(IDXGISwapChain3 *, const DXGI_MODE_DESC *);
    S32 (__stdcall *GetContainingOutput)(IDXGISwapChain3 *, IDXGIOutput **);
    S32 (__stdcall *GetFrameStatistics)(IDXGISwapChain3 *, DXGI_FRAME_STATISTICS *);
    S32 (__stdcall *GetLastPresentCount)(IDXGISwapChain3 *, U32 *);
    S32 (__stdcall *GetDesc1)(IDXGISwapChain3 *, DXGI_SWAP_CHAIN_DESC1 *);
    S32 (__stdcall *GetFullscreenDesc)(IDXGISwapChain3 *, DXGI_SWAP_CHAIN_FULLSCREEN_DESC *);
    S32 (__stdcall *GetHwnd)(IDXGISwapChain3 *, void **);
    S32 (__stdcall *GetCoreWindow)(IDXGISwapChain3 *, const GUID *, void **);
    S32 (__stdcall *Present1)(IDXGISwapChain3 *, U32, U32, const DXGI_PRESENT_PARAMETERS *);
    S32 (__stdcall *IsTemporaryMonoSupported)(IDXGISwapChain3 *);
    S32 (__stdcall *GetRestrictToOutput)(IDXGISwapChain3 *, IDXGIOutput **);
    S32 (__stdcall *SetBackgroundColor)(IDXGISwapChain3 *, const DXGI_RGBA *);
    S32 (__stdcall *GetBackgroundColor)(IDXGISwapChain3 *, DXGI_RGBA *);
    S32 (__stdcall *SetRotation)(IDXGISwapChain3 *, DXGI_MODE_ROTATION);
    S32 (__stdcall *GetRotation)(IDXGISwapChain3 *, DXGI_MODE_ROTATION *);
    S32 (__stdcall *SetSourceSize)(IDXGISwapChain3 *, U32, U32);
    S32 (__stdcall *GetSourceSize)(IDXGISwapChain3 *, U32 *, U32 *);
    S32 (__stdcall *SetMaximumFrameLatency)(IDXGISwapChain3 *, U32);
    S32 (__stdcall *GetMaximumFrameLatency)(IDXGISwapChain3 *, U32 *);
    void *(__stdcall *GetFrameLatencyWaitableObject)(IDXGISwapChain3 *);
    S32 (__stdcall *SetMatrixTransform)(IDXGISwapChain3 *, const DXGI_MATRIX_3X2_F *);
    S32 (__stdcall *GetMatrixTransform)(IDXGISwapChain3 *, DXGI_MATRIX_3X2_F *);
    U32 (__stdcall *GetCurrentBackBufferIndex)(IDXGISwapChain3 *);
    S32 (__stdcall *CheckColorSpaceSupport)(IDXGISwapChain3 *, DXGI_COLOR_SPACE_TYPE, U32 *);
    S32 (__stdcall *SetColorSpace1)(IDXGISwapChain3 *, DXGI_COLOR_SPACE_TYPE);
    S32 (__stdcall *ResizeBuffers1)(IDXGISwapChain3 *, U32, U32, U32, DXGI_FORMAT, U32, const U32 *, IUnknown *const *);
} IDXGISwapChain3Vt; struct IDXGISwapChain3 { const IDXGISwapChain3Vt *vt; };

static S32 (__stdcall *CreateDXGIFactory1)(const GUID *, void **);
//-------------------------------------------------------------------------------------------------
// D3D12
//-------------------------------------------------------------------------------------------------
typedef struct ID3D12Debug ID3D12Debug;
typedef struct ID3D12Device ID3D12Device;
typedef struct ID3D12DeviceChild ID3D12DeviceChild;
typedef struct ID3D12Pageable ID3D12Pageable;
typedef struct ID3D12CommandQueue ID3D12CommandQueue;
typedef struct ID3D12CommandList ID3D12CommandList;
typedef struct ID3D12GraphicsCommandList ID3D12GraphicsCommandList;
typedef struct ID3D12Fence ID3D12Fence;
typedef struct ID3D12Resource ID3D12Resource;
typedef struct ID3D12Heap ID3D12Heap;
typedef struct ID3D12RootSignature ID3D12RootSignature;
typedef struct ID3D12CommandAllocator ID3D12CommandAllocator;
typedef struct ID3D12PipelineState ID3D12PipelineState;
typedef struct ID3D12DescriptorHeap ID3D12DescriptorHeap;
typedef struct ID3D12QueryHeap ID3D12QueryHeap;
typedef struct ID3D12CommandSignature ID3D12CommandSignature;

typedef enum D3D_FEATURE_LEVEL { D3D_FEATURE_LEVEL_9_1 = 0x9100, D3D_FEATURE_LEVEL_9_2 = 0x9200, D3D_FEATURE_LEVEL_9_3 = 0x9300, D3D_FEATURE_LEVEL_10_0 = 0xa000, D3D_FEATURE_LEVEL_10_1 = 0xa100, D3D_FEATURE_LEVEL_11_0 = 0xb000, D3D_FEATURE_LEVEL_11_1 = 0xb100, D3D_FEATURE_LEVEL_12_0 = 0xc000, D3D_FEATURE_LEVEL_12_1 = 0xc100 } D3D_FEATURE_LEVEL;
typedef enum D3D12_FEATURE { D3D12_FEATURE_D3D12_OPTIONS = 0, D3D12_FEATURE_ARCHITECTURE = 1, D3D12_FEATURE_FEATURE_LEVELS = 2, D3D12_FEATURE_FORMAT_SUPPORT = 3, D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS = 4, D3D12_FEATURE_FORMAT_INFO = 5, D3D12_FEATURE_GPU_VIRTUAL_ADDRESS_SUPPORT = 6, D3D12_FEATURE_SHADER_MODEL = 7, D3D12_FEATURE_D3D12_OPTIONS1 = 8, D3D12_FEATURE_ROOT_SIGNATURE = 12 } D3D12_FEATURE;
typedef enum D3D12_COMMAND_QUEUE_FLAGS { D3D12_COMMAND_QUEUE_FLAG_NONE = 0, D3D12_COMMAND_QUEUE_FLAG_DISABLE_GPU_TIMEOUT = 0x1 } D3D12_COMMAND_QUEUE_FLAGS;
typedef enum D3D12_COMMAND_LIST_TYPE { D3D12_COMMAND_LIST_TYPE_DIRECT = 0, D3D12_COMMAND_LIST_TYPE_BUNDLE = 1, D3D12_COMMAND_LIST_TYPE_COMPUTE = 2, D3D12_COMMAND_LIST_TYPE_COPY = 3 } D3D12_COMMAND_LIST_TYPE;
typedef enum D3D12_COMMAND_QUEUE_PRIORITY { D3D12_COMMAND_QUEUE_PRIORITY_NORMAL = 0, D3D12_COMMAND_QUEUE_PRIORITY_HIGH = 100 } D3D12_COMMAND_QUEUE_PRIORITY;
typedef enum D3D12_TILE_RANGE_FLAGS { D3D12_TILE_RANGE_FLAG_NONE = 0, D3D12_TILE_RANGE_FLAG_NULL = 1, D3D12_TILE_RANGE_FLAG_SKIP = 2, D3D12_TILE_RANGE_FLAG_REUSE_SINGLE_TILE = 4 } D3D12_TILE_RANGE_FLAGS;
typedef enum D3D12_TILE_MAPPING_FLAGS { D3D12_TILE_MAPPING_FLAG_NONE = 0, D3D12_TILE_MAPPING_FLAG_NO_HAZARD = 0x1 } D3D12_TILE_MAPPING_FLAGS;
typedef enum D3D12_INDEX_BUFFER_STRIP_CUT_VALUE { D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED = 0, D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFF = 1, D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFFFFFF = 2 } D3D12_INDEX_BUFFER_STRIP_CUT_VALUE;
typedef enum D3D12_PIPELINE_STATE_FLAGS { D3D12_PIPELINE_STATE_FLAG_NONE = 0, D3D12_PIPELINE_STATE_FLAG_TOOL_DEBUG = 0x1 } D3D12_PIPELINE_STATE_FLAGS;
typedef enum D3D12_INPUT_CLASSIFICATION { D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA = 0, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA = 1 } D3D12_INPUT_CLASSIFICATION;
typedef enum D3D12_BLEND { D3D12_BLEND_ZERO = 1, D3D12_BLEND_ONE = 2, D3D12_BLEND_SRC_COLOR = 3, D3D12_BLEND_INV_SRC_COLOR = 4, D3D12_BLEND_SRC_ALPHA = 5, D3D12_BLEND_INV_SRC_ALPHA = 6, D3D12_BLEND_DEST_ALPHA = 7, D3D12_BLEND_INV_DEST_ALPHA = 8, D3D12_BLEND_DEST_COLOR = 9, D3D12_BLEND_INV_DEST_COLOR = 10, D3D12_BLEND_SRC_ALPHA_SAT = 11, D3D12_BLEND_BLEND_FACTOR = 14, D3D12_BLEND_INV_BLEND_FACTOR = 15, D3D12_BLEND_SRC1_COLOR = 16, D3D12_BLEND_INV_SRC1_COLOR = 17, D3D12_BLEND_SRC1_ALPHA = 18, D3D12_BLEND_INV_SRC1_ALPHA = 19 } D3D12_BLEND;
typedef enum D3D12_BLEND_OP { D3D12_BLEND_OP_ADD = 1, D3D12_BLEND_OP_SUBTRACT = 2, D3D12_BLEND_OP_REV_SUBTRACT = 3, D3D12_BLEND_OP_MIN = 4, D3D12_BLEND_OP_MAX = 5 } D3D12_BLEND_OP;
typedef enum D3D12_COLOR_WRITE_ENABLE { D3D12_COLOR_WRITE_ENABLE_RED = 1, D3D12_COLOR_WRITE_ENABLE_GREEN = 2, D3D12_COLOR_WRITE_ENABLE_BLUE = 4, D3D12_COLOR_WRITE_ENABLE_ALPHA = 8, D3D12_COLOR_WRITE_ENABLE_ALL = D3D12_COLOR_WRITE_ENABLE_RED | D3D12_COLOR_WRITE_ENABLE_GREEN | D3D12_COLOR_WRITE_ENABLE_BLUE | D3D12_COLOR_WRITE_ENABLE_ALPHA } D3D12_COLOR_WRITE_ENABLE;
typedef enum D3D12_LOGIC_OP { D3D12_LOGIC_OP_CLEAR = 0, D3D12_LOGIC_OP_SET = (D3D12_LOGIC_OP_CLEAR + 1), D3D12_LOGIC_OP_COPY = (D3D12_LOGIC_OP_SET + 1), D3D12_LOGIC_OP_COPY_INVERTED = (D3D12_LOGIC_OP_COPY + 1), D3D12_LOGIC_OP_NOOP = (D3D12_LOGIC_OP_COPY_INVERTED + 1), D3D12_LOGIC_OP_INVERT = (D3D12_LOGIC_OP_NOOP + 1), D3D12_LOGIC_OP_AND = (D3D12_LOGIC_OP_INVERT + 1), D3D12_LOGIC_OP_NAND = (D3D12_LOGIC_OP_AND + 1), D3D12_LOGIC_OP_OR = (D3D12_LOGIC_OP_NAND + 1), D3D12_LOGIC_OP_NOR = (D3D12_LOGIC_OP_OR + 1), D3D12_LOGIC_OP_XOR = (D3D12_LOGIC_OP_NOR + 1), D3D12_LOGIC_OP_EQUIV = (D3D12_LOGIC_OP_XOR + 1), D3D12_LOGIC_OP_AND_REVERSE = (D3D12_LOGIC_OP_EQUIV + 1), D3D12_LOGIC_OP_AND_INVERTED = (D3D12_LOGIC_OP_AND_REVERSE + 1), D3D12_LOGIC_OP_OR_REVERSE = (D3D12_LOGIC_OP_AND_INVERTED + 1), D3D12_LOGIC_OP_OR_INVERTED = (D3D12_LOGIC_OP_OR_REVERSE + 1) } D3D12_LOGIC_OP;
typedef enum D3D12_CULL_MODE { D3D12_CULL_MODE_NONE = 1, D3D12_CULL_MODE_FRONT = 2, D3D12_CULL_MODE_BACK = 3 } D3D12_CULL_MODE;
typedef enum D3D12_COMPARISON_FUNC { D3D12_COMPARISON_FUNC_NEVER = 1, D3D12_COMPARISON_FUNC_LESS = 2, D3D12_COMPARISON_FUNC_EQUAL = 3, D3D12_COMPARISON_FUNC_LESS_EQUAL = 4, D3D12_COMPARISON_FUNC_GREATER = 5, D3D12_COMPARISON_FUNC_NOT_EQUAL = 6, D3D12_COMPARISON_FUNC_GREATER_EQUAL = 7, D3D12_COMPARISON_FUNC_ALWAYS = 8 } D3D12_COMPARISON_FUNC;
typedef enum D3D12_DEPTH_WRITE_MASK { D3D12_DEPTH_WRITE_MASK_ZERO = 0, D3D12_DEPTH_WRITE_MASK_ALL = 1 } D3D12_DEPTH_WRITE_MASK;
typedef enum D3D12_STENCIL_OP { D3D12_STENCIL_OP_KEEP = 1, D3D12_STENCIL_OP_ZERO = 2, D3D12_STENCIL_OP_REPLACE = 3, D3D12_STENCIL_OP_INCR_SAT = 4, D3D12_STENCIL_OP_DECR_SAT = 5, D3D12_STENCIL_OP_INVERT = 6, D3D12_STENCIL_OP_INCR = 7, D3D12_STENCIL_OP_DECR = 8 } D3D12_STENCIL_OP;
typedef enum D3D12_CONSERVATIVE_RASTERIZATION_MODE { D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF = 0, D3D12_CONSERVATIVE_RASTERIZATION_MODE_ON = 1 } D3D12_CONSERVATIVE_RASTERIZATION_MODE;
typedef enum D3D12_FILL_MODE { D3D12_FILL_MODE_WIREFRAME = 2, D3D12_FILL_MODE_SOLID = 3 } D3D12_FILL_MODE;
typedef enum D3D12_PRIMITIVE_TOPOLOGY { D3D_PRIMITIVE_TOPOLOGY_UNDEFINED = 0, D3D_PRIMITIVE_TOPOLOGY_POINTLIST = 1, D3D_PRIMITIVE_TOPOLOGY_LINELIST = 2, D3D_PRIMITIVE_TOPOLOGY_LINESTRIP = 3, D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST = 4, D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = 5, D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ = 10, D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = 11, D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ = 12, D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = 13, D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST = 33, D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST = 34, D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST = 35, D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST = 36, D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST = 37, D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST = 38, D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST = 39, D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST = 40, D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST = 41, D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST = 42, D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST = 43, D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST = 44, D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST = 45, D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST = 46, D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST = 47, D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST = 48, D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST = 49, D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST = 50, D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST = 51, D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST = 52, D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST = 53, D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST = 54, D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST = 55, D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST = 56, D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST = 57, D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST = 58, D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST = 59, D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST = 60, D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST = 61, D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST = 62, D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST = 63, D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST = 64 } D3D12_PRIMITIVE_TOPOLOGY;
typedef enum D3D12_PRIMITIVE_TOPOLOGY_TYPE { D3D12_PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED = 0, D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT = 1, D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE = 2, D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE = 3, D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH = 4 } D3D12_PRIMITIVE_TOPOLOGY_TYPE;
typedef enum D3D12_DESCRIPTOR_HEAP_TYPE { D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV = 0, D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER = (D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV + 1), D3D12_DESCRIPTOR_HEAP_TYPE_RTV = (D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER + 1), D3D12_DESCRIPTOR_HEAP_TYPE_DSV = (D3D12_DESCRIPTOR_HEAP_TYPE_RTV + 1), D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES = (D3D12_DESCRIPTOR_HEAP_TYPE_DSV + 1) } D3D12_DESCRIPTOR_HEAP_TYPE;
typedef enum D3D12_DESCRIPTOR_HEAP_FLAGS { D3D12_DESCRIPTOR_HEAP_FLAG_NONE = 0, D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE = 0x1 } D3D12_DESCRIPTOR_HEAP_FLAGS;
typedef enum D3D12_BUFFER_SRV_FLAGS { D3D12_BUFFER_SRV_FLAG_NONE = 0, D3D12_BUFFER_SRV_FLAG_RAW = 0x1 } D3D12_BUFFER_SRV_FLAGS;
typedef enum D3D12_BUFFER_UAV_FLAGS { D3D12_BUFFER_UAV_FLAG_NONE = 0, D3D12_BUFFER_UAV_FLAG_RAW = 0x1 } D3D12_BUFFER_UAV_FLAGS;
typedef enum D3D12_SRV_DIMENSION { D3D12_SRV_DIMENSION_UNKNOWN = 0, D3D12_SRV_DIMENSION_BUFFER = 1, D3D12_SRV_DIMENSION_TEXTURE1D = 2, D3D12_SRV_DIMENSION_TEXTURE1DARRAY = 3, D3D12_SRV_DIMENSION_TEXTURE2D = 4, D3D12_SRV_DIMENSION_TEXTURE2DARRAY = 5, D3D12_SRV_DIMENSION_TEXTURE2DMS = 6, D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY = 7, D3D12_SRV_DIMENSION_TEXTURE3D = 8, D3D12_SRV_DIMENSION_TEXTURECUBE = 9, D3D12_SRV_DIMENSION_TEXTURECUBEARRAY = 10 } D3D12_SRV_DIMENSION;
typedef enum D3D12_UAV_DIMENSION { D3D12_UAV_DIMENSION_UNKNOWN = 0, D3D12_UAV_DIMENSION_BUFFER = 1, D3D12_UAV_DIMENSION_TEXTURE1D = 2, D3D12_UAV_DIMENSION_TEXTURE1DARRAY = 3, D3D12_UAV_DIMENSION_TEXTURE2D = 4, D3D12_UAV_DIMENSION_TEXTURE2DARRAY = 5, D3D12_UAV_DIMENSION_TEXTURE3D = 8 } D3D12_UAV_DIMENSION;
typedef enum D3D12_RTV_DIMENSION { D3D12_RTV_DIMENSION_UNKNOWN = 0, D3D12_RTV_DIMENSION_BUFFER = 1, D3D12_RTV_DIMENSION_TEXTURE1D = 2, D3D12_RTV_DIMENSION_TEXTURE1DARRAY = 3, D3D12_RTV_DIMENSION_TEXTURE2D = 4, D3D12_RTV_DIMENSION_TEXTURE2DARRAY = 5, D3D12_RTV_DIMENSION_TEXTURE2DMS = 6, D3D12_RTV_DIMENSION_TEXTURE2DMSARRAY = 7, D3D12_RTV_DIMENSION_TEXTURE3D = 8 } D3D12_RTV_DIMENSION;
typedef enum D3D12_DSV_DIMENSION { D3D12_DSV_DIMENSION_UNKNOWN = 0, D3D12_DSV_DIMENSION_TEXTURE1D = 1, D3D12_DSV_DIMENSION_TEXTURE1DARRAY = 2, D3D12_DSV_DIMENSION_TEXTURE2D = 3, D3D12_DSV_DIMENSION_TEXTURE2DARRAY = 4, D3D12_DSV_DIMENSION_TEXTURE2DMS = 5, D3D12_DSV_DIMENSION_TEXTURE2DMSARRAY = 6 } D3D12_DSV_DIMENSION;
typedef enum D3D12_DSV_FLAGS { D3D12_DSV_FLAG_NONE = 0, D3D12_DSV_FLAG_READ_ONLY_DEPTH = 0x1, D3D12_DSV_FLAG_READ_ONLY_STENCIL = 0x2 } D3D12_DSV_FLAGS;
typedef enum D3D12_FILTER { D3D12_FILTER_MIN_MAG_MIP_POINT = 0, D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR = 0x1, D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x4, D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR = 0x5, D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT = 0x10, D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11, D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT = 0x14, D3D12_FILTER_MIN_MAG_MIP_LINEAR = 0x15, D3D12_FILTER_ANISOTROPIC = 0x55, D3D12_FILTER_COMPARISON_MIN_MAG_MIP_POINT = 0x80, D3D12_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 0x81, D3D12_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x84, D3D12_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 0x85, D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 0x90, D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x91, D3D12_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 0x94, D3D12_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR = 0x95, D3D12_FILTER_COMPARISON_ANISOTROPIC = 0xd5, D3D12_FILTER_MINIMUM_MIN_MAG_MIP_POINT = 0x100, D3D12_FILTER_MINIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x101, D3D12_FILTER_MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x104, D3D12_FILTER_MINIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x105, D3D12_FILTER_MINIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x110, D3D12_FILTER_MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x111, D3D12_FILTER_MINIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x114, D3D12_FILTER_MINIMUM_MIN_MAG_MIP_LINEAR = 0x115, D3D12_FILTER_MINIMUM_ANISOTROPIC = 0x155, D3D12_FILTER_MAXIMUM_MIN_MAG_MIP_POINT = 0x180, D3D12_FILTER_MAXIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x181, D3D12_FILTER_MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x184, D3D12_FILTER_MAXIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x185, D3D12_FILTER_MAXIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x190, D3D12_FILTER_MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x191, D3D12_FILTER_MAXIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x194, D3D12_FILTER_MAXIMUM_MIN_MAG_MIP_LINEAR = 0x195, D3D12_FILTER_MAXIMUM_ANISOTROPIC = 0x1d5 } D3D12_FILTER;
typedef enum D3D12_FILTER_TYPE { D3D12_FILTER_TYPE_POINT = 0, D3D12_FILTER_TYPE_LINEAR = 1 } D3D12_FILTER_TYPE;
typedef enum D3D12_FILTER_REDUCTION_TYPE { D3D12_FILTER_REDUCTION_TYPE_STANDARD = 0, D3D12_FILTER_REDUCTION_TYPE_COMPARISON = 1, D3D12_FILTER_REDUCTION_TYPE_MINIMUM = 2, D3D12_FILTER_REDUCTION_TYPE_MAXIMUM = 3 } D3D12_FILTER_REDUCTION_TYPE;
typedef enum D3D12_TEXTURE_ADDRESS_MODE { D3D12_TEXTURE_ADDRESS_MODE_WRAP = 1, D3D12_TEXTURE_ADDRESS_MODE_MIRROR = 2, D3D12_TEXTURE_ADDRESS_MODE_CLAMP = 3, D3D12_TEXTURE_ADDRESS_MODE_BORDER = 4, D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE = 5 } D3D12_TEXTURE_ADDRESS_MODE;
typedef enum D3D12_RESOURCE_DIMENSION { D3D12_RESOURCE_DIMENSION_UNKNOWN = 0, D3D12_RESOURCE_DIMENSION_BUFFER = 1, D3D12_RESOURCE_DIMENSION_TEXTURE1D = 2, D3D12_RESOURCE_DIMENSION_TEXTURE2D = 3, D3D12_RESOURCE_DIMENSION_TEXTURE3D = 4 } D3D12_RESOURCE_DIMENSION;
typedef enum D3D12_TEXTURE_LAYOUT { D3D12_TEXTURE_LAYOUT_UNKNOWN = 0, D3D12_TEXTURE_LAYOUT_ROW_MAJOR = 1, D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE = 2, D3D12_TEXTURE_LAYOUT_64KB_STANDARD_SWIZZLE = 3 } D3D12_TEXTURE_LAYOUT;
typedef enum D3D12_RESOURCE_FLAGS { D3D12_RESOURCE_FLAG_NONE = 0, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET = 0x1, D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL = 0x2, D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS = 0x4, D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE = 0x8, D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER = 0x10, D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS = 0x20 } D3D12_RESOURCE_FLAGS;
typedef enum D3D12_HEAP_TYPE { D3D12_HEAP_TYPE_DEFAULT = 1, D3D12_HEAP_TYPE_UPLOAD = 2, D3D12_HEAP_TYPE_READBACK = 3, D3D12_HEAP_TYPE_CUSTOM = 4 } D3D12_HEAP_TYPE;
typedef enum D3D12_CPU_PAGE_PROPERTY { D3D12_CPU_PAGE_PROPERTY_UNKNOWN = 0, D3D12_CPU_PAGE_PROPERTY_NOT_AVAILABLE = 1, D3D12_CPU_PAGE_PROPERTY_WRITE_COMBINE = 2, D3D12_CPU_PAGE_PROPERTY_WRITE_BACK = 3 } D3D12_CPU_PAGE_PROPERTY;
typedef enum D3D12_MEMORY_POOL { D3D12_MEMORY_POOL_UNKNOWN = 0, D3D12_MEMORY_POOL_L0 = 1, D3D12_MEMORY_POOL_L1 = 2 } D3D12_MEMORY_POOL;
typedef enum D3D12_HEAP_FLAGS { D3D12_HEAP_FLAG_NONE = 0, D3D12_HEAP_FLAG_SHARED = 0x1, D3D12_HEAP_FLAG_DENY_BUFFERS = 0x4, D3D12_HEAP_FLAG_ALLOW_DISPLAY = 0x8, D3D12_HEAP_FLAG_SHARED_CROSS_ADAPTER = 0x20, D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES = 0x40, D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES = 0x80, D3D12_HEAP_FLAG_HARDWARE_PROTECTED = 0x100, D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES = 0, D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS = 0xc0, D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES = 0x44, D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES = 0x84 } D3D12_HEAP_FLAGS;
typedef enum D3D12_RESOURCE_STATES { D3D12_RESOURCE_STATE_COMMON = 0, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER = 0x1, D3D12_RESOURCE_STATE_INDEX_BUFFER = 0x2, D3D12_RESOURCE_STATE_RENDER_TARGET = 0x4, D3D12_RESOURCE_STATE_UNORDERED_ACCESS = 0x8, D3D12_RESOURCE_STATE_DEPTH_WRITE = 0x10, D3D12_RESOURCE_STATE_DEPTH_READ = 0x20, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE = 0x40, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE = 0x80, D3D12_RESOURCE_STATE_STREAM_OUT = 0x100, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT = 0x200, D3D12_RESOURCE_STATE_COPY_DEST = 0x400, D3D12_RESOURCE_STATE_COPY_SOURCE = 0x800, D3D12_RESOURCE_STATE_RESOLVE_DEST = 0x1000, D3D12_RESOURCE_STATE_RESOLVE_SOURCE = 0x2000, D3D12_RESOURCE_STATE_GENERIC_READ = (((((0x1 | 0x2) | 0x40) | 0x80) | 0x200) | 0x800), D3D12_RESOURCE_STATE_PRESENT = 0, D3D12_RESOURCE_STATE_PREDICATION = 0x200 } D3D12_RESOURCE_STATES;
typedef enum D3D12_FENCE_FLAGS { D3D12_FENCE_FLAG_NONE = 0, D3D12_FENCE_FLAG_SHARED = 0x1, D3D12_FENCE_FLAG_SHARED_CROSS_ADAPTER = 0x2 } D3D12_FENCE_FLAGS;
typedef enum D3D12_QUERY_HEAP_TYPE { D3D12_QUERY_HEAP_TYPE_OCCLUSION = 0, D3D12_QUERY_HEAP_TYPE_TIMESTAMP = 1, D3D12_QUERY_HEAP_TYPE_PIPELINE_STATISTICS = 2, D3D12_QUERY_HEAP_TYPE_SO_STATISTICS = 3 } D3D12_QUERY_HEAP_TYPE;
typedef enum D3D12_INDIRECT_ARGUMENT_TYPE { D3D12_INDIRECT_ARGUMENT_TYPE_DRAW = 0, D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED = (D3D12_INDIRECT_ARGUMENT_TYPE_DRAW + 1), D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH = (D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED + 1), D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH + 1), D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW + 1), D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT = (D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW + 1), D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT + 1), D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW + 1), D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW = (D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW + 1) } D3D12_INDIRECT_ARGUMENT_TYPE;
typedef enum D3D12_TEXTURE_COPY_TYPE { D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX = 0, D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT = 1 } D3D12_TEXTURE_COPY_TYPE;
typedef enum D3D12_TILE_COPY_FLAGS { D3D12_TILE_COPY_FLAG_NONE = 0, D3D12_TILE_COPY_FLAG_NO_HAZARD = 0x1, D3D12_TILE_COPY_FLAG_LINEAR_BUFFER_TO_SWIZZLED_TILED_RESOURCE = 0x2, D3D12_TILE_COPY_FLAG_SWIZZLED_TILED_RESOURCE_TO_LINEAR_BUFFER = 0x4 } D3D12_TILE_COPY_FLAGS;
typedef enum D3D12_RESOURCE_BARRIER_TYPE { D3D12_RESOURCE_BARRIER_TYPE_TRANSITION = 0, D3D12_RESOURCE_BARRIER_TYPE_ALIASING = (D3D12_RESOURCE_BARRIER_TYPE_TRANSITION + 1), D3D12_RESOURCE_BARRIER_TYPE_UAV = (D3D12_RESOURCE_BARRIER_TYPE_ALIASING + 1) } D3D12_RESOURCE_BARRIER_TYPE;
typedef enum D3D12_RESOURCE_BARRIER_FLAGS { D3D12_RESOURCE_BARRIER_FLAG_NONE = 0, D3D12_RESOURCE_BARRIER_FLAG_BEGIN_ONLY = 0x1, D3D12_RESOURCE_BARRIER_FLAG_END_ONLY = 0x2 } D3D12_RESOURCE_BARRIER_FLAGS;
typedef enum D3D12_CLEAR_FLAGS { D3D12_CLEAR_FLAG_DEPTH = 0x1, D3D12_CLEAR_FLAG_STENCIL = 0x2 } D3D12_CLEAR_FLAGS;
typedef enum D3D12_PREDICATION_OP { D3D12_PREDICATION_OP_EQUAL_ZERO = 0, D3D12_PREDICATION_OP_NOT_EQUAL_ZERO = 1 } D3D12_PREDICATION_OP;
typedef enum D3D12_QUERY_TYPE { D3D12_QUERY_TYPE_OCCLUSION = 0, D3D12_QUERY_TYPE_BINARY_OCCLUSION = 1, D3D12_QUERY_TYPE_TIMESTAMP = 2, D3D12_QUERY_TYPE_PIPELINE_STATISTICS = 3, D3D12_QUERY_TYPE_SO_STATISTICS_STREAM0 = 4, D3D12_QUERY_TYPE_SO_STATISTICS_STREAM1 = 5, D3D12_QUERY_TYPE_SO_STATISTICS_STREAM2 = 6, D3D12_QUERY_TYPE_SO_STATISTICS_STREAM3 = 7 } D3D12_QUERY_TYPE;

typedef U64 D3D12_GPU_VIRTUAL_ADDRESS;
typedef RECT D3D12_RECT;
typedef struct D3D12_CPU_DESCRIPTOR_HANDLE { U64 ptr; } D3D12_CPU_DESCRIPTOR_HANDLE;
typedef struct D3D12_GPU_DESCRIPTOR_HANDLE { U64 ptr; } D3D12_GPU_DESCRIPTOR_HANDLE;
typedef struct D3D12_CONSTANT_BUFFER_VIEW_DESC { D3D12_GPU_VIRTUAL_ADDRESS BufferLocation; U32 SizeInBytes; } D3D12_CONSTANT_BUFFER_VIEW_DESC;
typedef struct D3D12_DESCRIPTOR_HEAP_DESC { D3D12_DESCRIPTOR_HEAP_TYPE Type; U32 NumDescriptors; D3D12_DESCRIPTOR_HEAP_FLAGS Flags; U32 NodeMask; } D3D12_DESCRIPTOR_HEAP_DESC;
typedef struct D3D12_SO_DECLARATION_ENTRY { U32 Stream; const char *SemanticName; U32 SemanticIndex; U8 StartComponent; U8 ComponentCount; U8 OutputSlot; } D3D12_SO_DECLARATION_ENTRY;
typedef struct D3D12_STREAM_OUTPUT_DESC { const D3D12_SO_DECLARATION_ENTRY *pSODeclaration; U32 NumEntries; const U32 *pBufferStrides; U32 NumStrides; U32 RasterizedStream; } D3D12_STREAM_OUTPUT_DESC;
typedef struct D3D12_COMMAND_QUEUE_DESC { D3D12_COMMAND_LIST_TYPE Type; S32 Priority; D3D12_COMMAND_QUEUE_FLAGS Flags; U32 NodeMask; } D3D12_COMMAND_QUEUE_DESC;
typedef struct D3D12_TILED_RESOURCE_COORDINATE { U32 X; U32 Y; U32 Z; U32 Subresource; } D3D12_TILED_RESOURCE_COORDINATE;
typedef struct D3D12_TILE_REGION_SIZE { U32 NumTiles; S32 UseBox; U32 Width; U16 Height; U16 Depth; } D3D12_TILE_REGION_SIZE;
typedef struct D3D12_SHADER_BYTECODE { const void *pShaderBytecode; U64 BytecodeLength; } D3D12_SHADER_BYTECODE;
typedef struct D3D12_INPUT_ELEMENT_DESC { const char *SemanticName; U32 SemanticIndex; DXGI_FORMAT Format; U32 InputSlot; U32 AlignedByteOffset; D3D12_INPUT_CLASSIFICATION InputSlotClass; U32 InstanceDataStepRate; } D3D12_INPUT_ELEMENT_DESC;
typedef struct D3D12_INPUT_LAYOUT_DESC { const D3D12_INPUT_ELEMENT_DESC *pInputElementDescs; U32 NumElements; } D3D12_INPUT_LAYOUT_DESC;
typedef struct D3D12_CACHED_PIPELINE_STATE { const void *pCachedBlob; U64 CachedBlobSizeInBytes; } D3D12_CACHED_PIPELINE_STATE;
typedef struct D3D12_VIEWPORT { F32 TopLeftX; F32 TopLeftY; F32 Width; F32 Height; F32 MinDepth; F32 MaxDepth; } D3D12_VIEWPORT;
typedef struct D3D12_DEPTH_STENCILOP_DESC { D3D12_STENCIL_OP StencilFailOp; D3D12_STENCIL_OP StencilDepthFailOp; D3D12_STENCIL_OP StencilPassOp; D3D12_COMPARISON_FUNC StencilFunc; } D3D12_DEPTH_STENCILOP_DESC;
typedef struct D3D12_DEPTH_STENCIL_DESC { S32 DepthEnable; D3D12_DEPTH_WRITE_MASK DepthWriteMask; D3D12_COMPARISON_FUNC DepthFunc; S32 StencilEnable; U8 StencilReadMask; U8 StencilWriteMask; D3D12_DEPTH_STENCILOP_DESC FrontFace; D3D12_DEPTH_STENCILOP_DESC BackFace; } D3D12_DEPTH_STENCIL_DESC;
typedef struct D3D12_RENDER_TARGET_BLEND_DESC { S32 BlendEnable; S32 LogicOpEnable; D3D12_BLEND SrcBlend; D3D12_BLEND DestBlend; D3D12_BLEND_OP BlendOp; D3D12_BLEND SrcBlendAlpha; D3D12_BLEND DestBlendAlpha; D3D12_BLEND_OP BlendOpAlpha; D3D12_LOGIC_OP LogicOp; U8 RenderTargetWriteMask; } D3D12_RENDER_TARGET_BLEND_DESC;
typedef struct D3D12_BLEND_DESC { S32 AlphaToCoverageEnable; S32 IndependentBlendEnable; D3D12_RENDER_TARGET_BLEND_DESC RenderTarget[8]; } D3D12_BLEND_DESC;
typedef struct D3D12_RASTERIZER_DESC { D3D12_FILL_MODE FillMode; D3D12_CULL_MODE CullMode; S32 FrontCounterClockwise; S32 DepthBias; F32 DepthBiasClamp; F32 SlopeScaledDepthBias; S32 DepthClipEnable; S32 MultisampleEnable; S32 AntialiasedLineEnable; U32 ForcedSampleCount; D3D12_CONSERVATIVE_RASTERIZATION_MODE ConservativeRaster; } D3D12_RASTERIZER_DESC;
typedef struct D3D12_GRAPHICS_PIPELINE_STATE_DESC { ID3D12RootSignature *pRootSignature; D3D12_SHADER_BYTECODE VS; D3D12_SHADER_BYTECODE PS; D3D12_SHADER_BYTECODE DS; D3D12_SHADER_BYTECODE HS; D3D12_SHADER_BYTECODE GS; D3D12_STREAM_OUTPUT_DESC StreamOutput; D3D12_BLEND_DESC BlendState; U32 SampleMask; D3D12_RASTERIZER_DESC RasterizerState; D3D12_DEPTH_STENCIL_DESC DepthStencilState; D3D12_INPUT_LAYOUT_DESC InputLayout; D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue; D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyType; U32 NumRenderTargets; DXGI_FORMAT RTVFormats[8]; DXGI_FORMAT DSVFormat; DXGI_SAMPLE_DESC SampleDesc; U32 NodeMask; D3D12_CACHED_PIPELINE_STATE CachedPSO; D3D12_PIPELINE_STATE_FLAGS Flags; } D3D12_GRAPHICS_PIPELINE_STATE_DESC;
typedef struct D3D12_COMPUTE_PIPELINE_STATE_DESC { ID3D12RootSignature *pRootSignature; D3D12_SHADER_BYTECODE CS; U32 NodeMask; D3D12_CACHED_PIPELINE_STATE CachedPSO; D3D12_PIPELINE_STATE_FLAGS Flags; } D3D12_COMPUTE_PIPELINE_STATE_DESC;
typedef struct D3D12_BUFFER_SRV { U64 FirstElement; U32 NumElements; U32 StructureByteStride; D3D12_BUFFER_SRV_FLAGS Flags; } D3D12_BUFFER_SRV;
typedef struct D3D12_TEX1D_SRV { U32 MostDetailedMip; U32 MipLevels; F32 ResourceMinLODClamp; } D3D12_TEX1D_SRV;
typedef struct D3D12_TEX1D_ARRAY_SRV { U32 MostDetailedMip; U32 MipLevels; U32 FirstArraySlice; U32 ArraySize; F32 ResourceMinLODClamp; } D3D12_TEX1D_ARRAY_SRV;
typedef struct D3D12_TEX2D_SRV { U32 MostDetailedMip; U32 MipLevels; U32 PlaneSlice; F32 ResourceMinLODClamp; } D3D12_TEX2D_SRV;
typedef struct D3D12_TEX2D_ARRAY_SRV { U32 MostDetailedMip; U32 MipLevels; U32 FirstArraySlice; U32 ArraySize; U32 PlaneSlice; F32 ResourceMinLODClamp; } D3D12_TEX2D_ARRAY_SRV;
typedef struct D3D12_TEX3D_SRV { U32 MostDetailedMip; U32 MipLevels; F32 ResourceMinLODClamp; } D3D12_TEX3D_SRV;
typedef struct D3D12_TEXCUBE_SRV { U32 MostDetailedMip; U32 MipLevels; F32 ResourceMinLODClamp; } D3D12_TEXCUBE_SRV;
typedef struct D3D12_TEXCUBE_ARRAY_SRV { U32 MostDetailedMip; U32 MipLevels; U32 First2DArrayFace; U32 NumCubes; F32 ResourceMinLODClamp; } D3D12_TEXCUBE_ARRAY_SRV;
typedef struct D3D12_TEX2DMS_SRV { U32 UnusedField_NothingToDefine; } D3D12_TEX2DMS_SRV;
typedef struct D3D12_TEX2DMS_ARRAY_SRV { U32 FirstArraySlice; U32 ArraySize; } D3D12_TEX2DMS_ARRAY_SRV;
typedef struct D3D12_SHADER_RESOURCE_VIEW_DESC { DXGI_FORMAT Format; D3D12_SRV_DIMENSION ViewDimension; U32 Shader4ComponentMapping; union { D3D12_BUFFER_SRV Buffer; D3D12_TEX1D_SRV Texture1D; D3D12_TEX1D_ARRAY_SRV Texture1DArray; D3D12_TEX2D_SRV Texture2D; D3D12_TEX2D_ARRAY_SRV Texture2DArray; D3D12_TEX2DMS_SRV Texture2DMS; D3D12_TEX2DMS_ARRAY_SRV Texture2DMSArray; D3D12_TEX3D_SRV Texture3D; D3D12_TEXCUBE_SRV TextureCube; D3D12_TEXCUBE_ARRAY_SRV TextureCubeArray; }; } D3D12_SHADER_RESOURCE_VIEW_DESC;
typedef struct D3D12_BUFFER_UAV { U64 FirstElement; U32 NumElements; U32 StructureByteStride; U64 CounterOffsetInBytes; D3D12_BUFFER_UAV_FLAGS Flags; } D3D12_BUFFER_UAV;
typedef struct D3D12_TEX1D_UAV { U32 MipSlice; } D3D12_TEX1D_UAV;
typedef struct D3D12_TEX1D_ARRAY_UAV { U32 MipSlice; U32 FirstArraySlice; U32 ArraySize; } D3D12_TEX1D_ARRAY_UAV;
typedef struct D3D12_TEX2D_UAV { U32 MipSlice; U32 PlaneSlice; } D3D12_TEX2D_UAV;
typedef struct D3D12_TEX2D_ARRAY_UAV { U32 MipSlice; U32 FirstArraySlice; U32 ArraySize; U32 PlaneSlice; } D3D12_TEX2D_ARRAY_UAV;
typedef struct D3D12_TEX3D_UAV { U32 MipSlice; U32 FirstWSlice; U32 WSize; } D3D12_TEX3D_UAV;
typedef struct D3D12_UNORDERED_ACCESS_VIEW_DESC { DXGI_FORMAT Format; D3D12_UAV_DIMENSION ViewDimension; union { D3D12_BUFFER_UAV Buffer; D3D12_TEX1D_UAV Texture1D; D3D12_TEX1D_ARRAY_UAV Texture1DArray; D3D12_TEX2D_UAV Texture2D; D3D12_TEX2D_ARRAY_UAV Texture2DArray; D3D12_TEX3D_UAV Texture3D; }; } D3D12_UNORDERED_ACCESS_VIEW_DESC;
typedef struct D3D12_BUFFER_RTV { U64 FirstElement; U32 NumElements; } D3D12_BUFFER_RTV;
typedef struct D3D12_TEX1D_RTV { U32 MipSlice; } D3D12_TEX1D_RTV;
typedef struct D3D12_TEX1D_ARRAY_RTV { U32 MipSlice; U32 FirstArraySlice; U32 ArraySize; } D3D12_TEX1D_ARRAY_RTV;
typedef struct D3D12_TEX2D_RTV { U32 MipSlice; U32 PlaneSlice; } D3D12_TEX2D_RTV;
typedef struct D3D12_TEX2DMS_RTV { U32 UnusedField_NothingToDefine; } D3D12_TEX2DMS_RTV;
typedef struct D3D12_TEX2D_ARRAY_RTV { U32 MipSlice; U32 FirstArraySlice; U32 ArraySize; U32 PlaneSlice; } D3D12_TEX2D_ARRAY_RTV;
typedef struct D3D12_TEX2DMS_ARRAY_RTV { U32 FirstArraySlice; U32 ArraySize; } D3D12_TEX2DMS_ARRAY_RTV;
typedef struct D3D12_TEX3D_RTV { U32 MipSlice; U32 FirstWSlice; U32 WSize; } D3D12_TEX3D_RTV;
typedef struct D3D12_RENDER_TARGET_VIEW_DESC { DXGI_FORMAT Format; D3D12_RTV_DIMENSION ViewDimension; union { D3D12_BUFFER_RTV Buffer; D3D12_TEX1D_RTV Texture1D; D3D12_TEX1D_ARRAY_RTV Texture1DArray; D3D12_TEX2D_RTV Texture2D; D3D12_TEX2D_ARRAY_RTV Texture2DArray; D3D12_TEX2DMS_RTV Texture2DMS; D3D12_TEX2DMS_ARRAY_RTV Texture2DMSArray; D3D12_TEX3D_RTV Texture3D; }; } D3D12_RENDER_TARGET_VIEW_DESC;
typedef struct D3D12_TEX1D_DSV { U32 MipSlice; } D3D12_TEX1D_DSV;
typedef struct D3D12_TEX1D_ARRAY_DSV { U32 MipSlice; U32 FirstArraySlice; U32 ArraySize; } D3D12_TEX1D_ARRAY_DSV;
typedef struct D3D12_TEX2D_DSV { U32 MipSlice; } D3D12_TEX2D_DSV;
typedef struct D3D12_TEX2D_ARRAY_DSV { U32 MipSlice; U32 FirstArraySlice; U32 ArraySize; } D3D12_TEX2D_ARRAY_DSV;
typedef struct D3D12_TEX2DMS_DSV { U32 UnusedField_NothingToDefine; } D3D12_TEX2DMS_DSV;
typedef struct D3D12_TEX2DMS_ARRAY_DSV { U32 FirstArraySlice; U32 ArraySize; } D3D12_TEX2DMS_ARRAY_DSV;
typedef struct D3D12_DEPTH_STENCIL_VIEW_DESC { DXGI_FORMAT Format; D3D12_DSV_DIMENSION ViewDimension; D3D12_DSV_FLAGS Flags; union { D3D12_TEX1D_DSV Texture1D; D3D12_TEX1D_ARRAY_DSV Texture1DArray; D3D12_TEX2D_DSV Texture2D; D3D12_TEX2D_ARRAY_DSV Texture2DArray; D3D12_TEX2DMS_DSV Texture2DMS; D3D12_TEX2DMS_ARRAY_DSV Texture2DMSArray; }; } D3D12_DEPTH_STENCIL_VIEW_DESC;
typedef struct D3D12_DEPTH_STENCIL_VALUE { F32 Depth; U8 Stencil; } D3D12_DEPTH_STENCIL_VALUE;
typedef struct D3D12_CLEAR_VALUE { DXGI_FORMAT Format; union { F32 Color[4]; D3D12_DEPTH_STENCIL_VALUE DepthStencil; }; } D3D12_CLEAR_VALUE;
typedef struct D3D12_SAMPLER_DESC { D3D12_FILTER Filter; D3D12_TEXTURE_ADDRESS_MODE AddressU; D3D12_TEXTURE_ADDRESS_MODE AddressV; D3D12_TEXTURE_ADDRESS_MODE AddressW; F32 MipLODBias; U32 MaxAnisotropy; D3D12_COMPARISON_FUNC ComparisonFunc; F32 BorderColor[4]; F32 MinLOD; F32 MaxLOD; } D3D12_SAMPLER_DESC;
typedef struct D3D12_RESOURCE_ALLOCATION_INFO { U64 SizeInBytes; U64 Alignment; } D3D12_RESOURCE_ALLOCATION_INFO;
typedef struct D3D12_RESOURCE_DESC { D3D12_RESOURCE_DIMENSION Dimension; U64 Alignment; U64 Width; U32 Height; U16 DepthOrArraySize; U16 MipLevels; DXGI_FORMAT Format; DXGI_SAMPLE_DESC SampleDesc; D3D12_TEXTURE_LAYOUT Layout; D3D12_RESOURCE_FLAGS Flags; } D3D12_RESOURCE_DESC;
typedef struct D3D12_HEAP_PROPERTIES { D3D12_HEAP_TYPE Type; D3D12_CPU_PAGE_PROPERTY CPUPageProperty; D3D12_MEMORY_POOL MemoryPoolPreference; U32 CreationNodeMask; U32 VisibleNodeMask; } D3D12_HEAP_PROPERTIES;
typedef struct D3D12_HEAP_DESC { U64 SizeInBytes; D3D12_HEAP_PROPERTIES Properties; U64 Alignment; D3D12_HEAP_FLAGS Flags; } D3D12_HEAP_DESC;
typedef struct D3D12_RANGE { U64 Begin; U64 End; } D3D12_RANGE;
typedef struct D3D12_SUBRESOURCE_FOOTPRINT { DXGI_FORMAT Format; U32 Width; U32 Height; U32 Depth; U32 RowPitch; } D3D12_SUBRESOURCE_FOOTPRINT;
typedef struct D3D12_PLACED_SUBRESOURCE_FOOTPRINT { U64 Offset; D3D12_SUBRESOURCE_FOOTPRINT Footprint; } D3D12_PLACED_SUBRESOURCE_FOOTPRINT;
typedef struct D3D12_QUERY_HEAP_DESC { D3D12_QUERY_HEAP_TYPE Type; U32 Count; U32 NodeMask; } D3D12_QUERY_HEAP_DESC;
typedef struct D3D12_INDIRECT_ARGUMENT_DESC { D3D12_INDIRECT_ARGUMENT_TYPE Type; union { struct { U32 Slot; } VertexBuffer; struct { U32 RootParameterIndex; U32 DestOffsetIn32BitValues; U32 Num32BitValuesToSet; } Constant; struct { U32 RootParameterIndex; } ConstantBufferView; struct { U32 RootParameterIndex; } ShaderResourceView; struct { U32 RootParameterIndex; } UnorderedAccessView; }; } D3D12_INDIRECT_ARGUMENT_DESC;
typedef struct D3D12_COMMAND_SIGNATURE_DESC { U32 ByteStride; U32 NumArgumentDescs; const D3D12_INDIRECT_ARGUMENT_DESC *pArgumentDescs; U32 NodeMask; } D3D12_COMMAND_SIGNATURE_DESC;
typedef struct D3D12_PACKED_MIP_INFO { U8 NumStandardMips; U8 NumPackedMips; U32 NumTilesForPackedMips; U32 StartTileIndexInOverallResource; } D3D12_PACKED_MIP_INFO;
typedef struct D3D12_SUBRESOURCE_TILING { U32 WidthInTiles; U16 HeightInTiles; U16 DepthInTiles; U32 StartTileIndexInOverallResource; } D3D12_SUBRESOURCE_TILING;
typedef struct D3D12_TILE_SHAPE { U32 WidthInTexels; U32 HeightInTexels; U32 DepthInTexels; } D3D12_TILE_SHAPE;
typedef struct D3D12_TEXTURE_COPY_LOCATION { ID3D12Resource *pResource; D3D12_TEXTURE_COPY_TYPE Type; union { D3D12_PLACED_SUBRESOURCE_FOOTPRINT PlacedFootprint; U32 SubresourceIndex; }; } D3D12_TEXTURE_COPY_LOCATION;
typedef struct D3D12_BOX { U32 left; U32 top; U32 front; U32 right; U32 bottom; U32 back; } D3D12_BOX;
typedef struct D3D12_RESOURCE_TRANSITION_BARRIER { ID3D12Resource *pResource; U32 Subresource; D3D12_RESOURCE_STATES StateBefore; D3D12_RESOURCE_STATES StateAfter; } D3D12_RESOURCE_TRANSITION_BARRIER;
typedef struct D3D12_RESOURCE_ALIASING_BARRIER { ID3D12Resource *pResourceBefore; ID3D12Resource *pResourceAfter; } D3D12_RESOURCE_ALIASING_BARRIER;
typedef struct D3D12_RESOURCE_UAV_BARRIER { ID3D12Resource *pResource; } D3D12_RESOURCE_UAV_BARRIER;
typedef struct D3D12_RESOURCE_BARRIER { D3D12_RESOURCE_BARRIER_TYPE Type; D3D12_RESOURCE_BARRIER_FLAGS Flags; union { D3D12_RESOURCE_TRANSITION_BARRIER Transition; D3D12_RESOURCE_ALIASING_BARRIER Aliasing; D3D12_RESOURCE_UAV_BARRIER UAV; }; } D3D12_RESOURCE_BARRIER;
typedef struct D3D12_VERTEX_BUFFER_VIEW { D3D12_GPU_VIRTUAL_ADDRESS BufferLocation; U32 SizeInBytes; U32 StrideInBytes; } D3D12_VERTEX_BUFFER_VIEW;
typedef struct D3D12_INDEX_BUFFER_VIEW { D3D12_GPU_VIRTUAL_ADDRESS BufferLocation; U32 SizeInBytes; DXGI_FORMAT Format; } D3D12_INDEX_BUFFER_VIEW;
typedef struct D3D12_STREAM_OUTPUT_BUFFER_VIEW { D3D12_GPU_VIRTUAL_ADDRESS BufferLocation; U64 SizeInBytes; D3D12_GPU_VIRTUAL_ADDRESS BufferFilledSizeLocation; } D3D12_STREAM_OUTPUT_BUFFER_VIEW;
typedef struct D3D12_DISCARD_REGION { U32 NumRects; const D3D12_RECT *pRects; U32 FirstSubresource; U32 NumSubresources; } D3D12_DISCARD_REGION;

typedef struct ID3D12DebugVt {
    S32 (__stdcall *QueryInterface)(ID3D12Debug *, const GUID *, void **);
    U32 (__stdcall *AddRef)(ID3D12Debug *);
    U32 (__stdcall *Release)(ID3D12Debug *);
    void (__stdcall *EnableDebugLayer)(ID3D12Debug *);
} ID3D12DebugVt; struct ID3D12Debug { const ID3D12DebugVt *vt; };

typedef struct ID3D12DescriptorHeapVt {
    S32 (__stdcall *QueryInterface)(ID3D12DescriptorHeap *, const GUID *, void **);
    U32 (__stdcall *AddRef)(ID3D12DescriptorHeap *);
    U32 (__stdcall *Release)(ID3D12DescriptorHeap *);
    S32 (__stdcall *GetPrivateData)(ID3D12DescriptorHeap *, const GUID *, U32 *, void *);
    S32 (__stdcall *SetPrivateData)(ID3D12DescriptorHeap *, const GUID *, U32, const void *);
    S32 (__stdcall *SetPrivateDataInterface)(ID3D12DescriptorHeap *, const GUID *, const IUnknown *);
    S32 (__stdcall *SetName)(ID3D12DescriptorHeap *, const U16 *);
    S32 (__stdcall *GetDevice)(ID3D12DescriptorHeap *, const GUID *, void **);
    D3D12_DESCRIPTOR_HEAP_DESC *(__stdcall *GetDesc)(ID3D12DescriptorHeap *, D3D12_DESCRIPTOR_HEAP_DESC *);
    D3D12_CPU_DESCRIPTOR_HANDLE *(__stdcall *GetCPUDescriptorHandleForHeapStart)(ID3D12DescriptorHeap *, D3D12_CPU_DESCRIPTOR_HANDLE *);
    D3D12_GPU_DESCRIPTOR_HANDLE *(__stdcall *GetGPUDescriptorHandleForHeapStart)(ID3D12DescriptorHeap *, D3D12_GPU_DESCRIPTOR_HANDLE *);
} ID3D12DescriptorHeapVt; struct ID3D12DescriptorHeap { const ID3D12DescriptorHeapVt *vt; };

typedef struct ID3D12ResourceVt {
    S32 (__stdcall *QueryInterface)(ID3D12Resource *, const GUID *, void **);
    U32 (__stdcall *AddRef)(ID3D12Resource *);
    U32 (__stdcall *Release)(ID3D12Resource *);
    S32 (__stdcall *GetPrivateData)(ID3D12Resource *, const GUID *, U32 *, void *);
    S32 (__stdcall *SetPrivateData)(ID3D12Resource *, const GUID *, U32, const void *);
    S32 (__stdcall *SetPrivateDataInterface)(ID3D12Resource *, const GUID *, const IUnknown *);
    S32 (__stdcall *SetName)(ID3D12Resource *, const U16 *);
    S32 (__stdcall *GetDevice)(ID3D12Resource *, const GUID *, void **);
    S32 (__stdcall *Map)(ID3D12Resource *, U32, const D3D12_RANGE *, void **);
    void (__stdcall *Unmap)(ID3D12Resource *, U32, const D3D12_RANGE *);
    D3D12_RESOURCE_DESC *(__stdcall *GetDesc)(ID3D12Resource *, D3D12_RESOURCE_DESC *);
    D3D12_GPU_VIRTUAL_ADDRESS (__stdcall *GetGPUVirtualAddress)(ID3D12Resource *);
    S32 (__stdcall *WriteToSubresource)(ID3D12Resource *, U32, const D3D12_BOX *, const void *, U32, U32);
    S32 (__stdcall *ReadFromSubresource)(ID3D12Resource *, void *, U32, U32, U32, const D3D12_BOX *);
    S32 (__stdcall *GetHeapProperties)(ID3D12Resource *, D3D12_HEAP_PROPERTIES *, D3D12_HEAP_FLAGS *);
} ID3D12ResourceVt; struct ID3D12Resource { const ID3D12ResourceVt *vt; };

typedef struct ID3D12CommandAllocatorVt {
    S32 (__stdcall *QueryInterface)(ID3D12CommandAllocator *, const GUID *, void **);
    U32 (__stdcall *AddRef)(ID3D12CommandAllocator *);
    U32 (__stdcall *Release)(ID3D12CommandAllocator *);
    S32 (__stdcall *GetPrivateData)(ID3D12CommandAllocator *, const GUID *, U32 *, void *);
    S32 (__stdcall *SetPrivateData)(ID3D12CommandAllocator *, const GUID *, U32, const void *);
    S32 (__stdcall *SetPrivateDataInterface)(ID3D12CommandAllocator *, const GUID *, const IUnknown *);
    S32 (__stdcall *SetName)(ID3D12CommandAllocator *, const U16 *);
    S32 (__stdcall *GetDevice)(ID3D12CommandAllocator *, const GUID *, void **);
    S32 (__stdcall *Reset)(ID3D12CommandAllocator *);
} ID3D12CommandAllocatorVt; struct ID3D12CommandAllocator { const ID3D12CommandAllocatorVt *vt; };

typedef struct ID3D12FenceVt {
    S32 (__stdcall *QueryInterface)(ID3D12Fence *, const GUID *, void **);
    U32 (__stdcall *AddRef)(ID3D12Fence *);
    U32 (__stdcall *Release)(ID3D12Fence *);
    S32 (__stdcall *GetPrivateData)(ID3D12Fence *, const GUID *, U32 *, void *);
    S32 (__stdcall *SetPrivateData)(ID3D12Fence *, const GUID *, U32, const void *);
    S32 (__stdcall *SetPrivateDataInterface)(ID3D12Fence *, const GUID *, const IUnknown *);
    S32 (__stdcall *SetName)(ID3D12Fence *, const U16 *);
    S32 (__stdcall *GetDevice)(ID3D12Fence *, const GUID *, void **);
    U64 (__stdcall *GetCompletedValue)(ID3D12Fence *);
    S32 (__stdcall *SetEventOnCompletion)(ID3D12Fence *, U64, void *);
    S32 (__stdcall *Signal)(ID3D12Fence *, U64);
} ID3D12FenceVt; struct ID3D12Fence { const ID3D12FenceVt *vt; };

typedef struct ID3D12CommandQueueVt {
    S32 (__stdcall *QueryInterface)(ID3D12CommandQueue *, const GUID *, void **);
    U32 (__stdcall *AddRef)(ID3D12CommandQueue *);
    U32 (__stdcall *Release)(ID3D12CommandQueue *);
    S32 (__stdcall *GetPrivateData)(ID3D12CommandQueue *, const GUID *, U32 *, void *);
    S32 (__stdcall *SetPrivateData)(ID3D12CommandQueue *, const GUID *, U32, const void *);
    S32 (__stdcall *SetPrivateDataInterface)(ID3D12CommandQueue *, const GUID *, const IUnknown *);
    S32 (__stdcall *SetName)(ID3D12CommandQueue *, const U16 *);
    S32 (__stdcall *GetDevice)(ID3D12CommandQueue *, const GUID *, void **);
    void (__stdcall *UpdateTileMappings)(ID3D12CommandQueue *, ID3D12Resource *, U32, const D3D12_TILED_RESOURCE_COORDINATE *, const D3D12_TILE_REGION_SIZE *, ID3D12Heap *, U32, const D3D12_TILE_RANGE_FLAGS *, const U32 *, const U32 *, D3D12_TILE_MAPPING_FLAGS);
    void (__stdcall *CopyTileMappings)(ID3D12CommandQueue *, ID3D12Resource *, const D3D12_TILED_RESOURCE_COORDINATE *, ID3D12Resource *, const D3D12_TILED_RESOURCE_COORDINATE *, const D3D12_TILE_REGION_SIZE *, D3D12_TILE_MAPPING_FLAGS);
    void (__stdcall *ExecuteCommandLists)(ID3D12CommandQueue *, U32, ID3D12CommandList *const *);
    void (__stdcall *SetMarker)(ID3D12CommandQueue *, U32, const void *, U32);
    void (__stdcall *BeginEvent)(ID3D12CommandQueue *, U32, const void *, U32);
    void (__stdcall *EndEvent)(ID3D12CommandQueue *);
    S32 (__stdcall *Signal)(ID3D12CommandQueue *, ID3D12Fence *, U64);
    S32 (__stdcall *Wait)(ID3D12CommandQueue *, ID3D12Fence *, U64);
    S32 (__stdcall *GetTimestampFrequency)(ID3D12CommandQueue *, U64 *);
    S32 (__stdcall *GetClockCalibration)(ID3D12CommandQueue *, U64 *, U64 *);
    D3D12_COMMAND_QUEUE_DESC *(__stdcall *GetDesc)(ID3D12CommandQueue *, D3D12_COMMAND_QUEUE_DESC *);
} ID3D12CommandQueueVt; struct ID3D12CommandQueue { const ID3D12CommandQueueVt *vt; };

typedef struct ID3D12GraphicsCommandListVt {
    S32 (__stdcall *QueryInterface)(ID3D12GraphicsCommandList *, const GUID *, void **);
    U32 (__stdcall *AddRef)(ID3D12GraphicsCommandList *);
    U32 (__stdcall *Release)(ID3D12GraphicsCommandList *);
    S32 (__stdcall *GetPrivateData)(ID3D12GraphicsCommandList *, const GUID *, U32 *, void *);
    S32 (__stdcall *SetPrivateData)(ID3D12GraphicsCommandList *, const GUID *, U32, const void *);
    S32 (__stdcall *SetPrivateDataInterface)(ID3D12GraphicsCommandList *, const GUID *, const IUnknown *);
    S32 (__stdcall *SetName)(ID3D12GraphicsCommandList *, const U16 *);
    S32 (__stdcall *GetDevice)(ID3D12GraphicsCommandList *, const GUID *, void **);
    D3D12_COMMAND_LIST_TYPE (__stdcall *GetType)(ID3D12GraphicsCommandList *);
    S32 (__stdcall *Close)(ID3D12GraphicsCommandList *);
    S32 (__stdcall *Reset)(ID3D12GraphicsCommandList *, ID3D12CommandAllocator *, ID3D12PipelineState *);
    void (__stdcall *ClearState)(ID3D12GraphicsCommandList *, ID3D12PipelineState *);
    void (__stdcall *DrawInstanced)(ID3D12GraphicsCommandList *, U32, U32, U32, U32);
    void (__stdcall *DrawIndexedInstanced)(ID3D12GraphicsCommandList *, U32, U32, U32, S32, U32);
    void (__stdcall *Dispatch)(ID3D12GraphicsCommandList *, U32, U32, U32);
    void (__stdcall *CopyBufferRegion)(ID3D12GraphicsCommandList *, ID3D12Resource *, U64, ID3D12Resource *, U64, U64);
    void (__stdcall *CopyTextureRegion)(ID3D12GraphicsCommandList *, const D3D12_TEXTURE_COPY_LOCATION *, U32, U32, U32, const D3D12_TEXTURE_COPY_LOCATION *, const D3D12_BOX *);
    void (__stdcall *CopyResource)(ID3D12GraphicsCommandList *, ID3D12Resource *, ID3D12Resource *);
    void (__stdcall *CopyTiles)(ID3D12GraphicsCommandList *, ID3D12Resource *, const D3D12_TILED_RESOURCE_COORDINATE *, const D3D12_TILE_REGION_SIZE *, ID3D12Resource *, U64, D3D12_TILE_COPY_FLAGS);
    void (__stdcall *ResolveSubresource)(ID3D12GraphicsCommandList *, ID3D12Resource *, U32, ID3D12Resource *, U32, DXGI_FORMAT);
    void (__stdcall *IASetPrimitiveTopology)(ID3D12GraphicsCommandList *, D3D12_PRIMITIVE_TOPOLOGY);
    void (__stdcall *RSSetViewports)(ID3D12GraphicsCommandList *, U32, const D3D12_VIEWPORT *);
    void (__stdcall *RSSetScissorRects)(ID3D12GraphicsCommandList *, U32, const D3D12_RECT *);
    void (__stdcall *OMSetBlendFactor)(ID3D12GraphicsCommandList *, const F32 [4]);
    void (__stdcall *OMSetStencilRef)(ID3D12GraphicsCommandList *, U32);
    void (__stdcall *SetPipelineState)(ID3D12GraphicsCommandList *, ID3D12PipelineState *);
    void (__stdcall *ResourceBarrier)(ID3D12GraphicsCommandList *, U32, const D3D12_RESOURCE_BARRIER *);
    void (__stdcall *ExecuteBundle)(ID3D12GraphicsCommandList *, ID3D12GraphicsCommandList *);
    void (__stdcall *SetDescriptorHeaps)(ID3D12GraphicsCommandList *, U32, ID3D12DescriptorHeap *const *);
    void (__stdcall *SetComputeRootSignature)(ID3D12GraphicsCommandList *, ID3D12RootSignature *);
    void (__stdcall *SetGraphicsRootSignature)(ID3D12GraphicsCommandList *, ID3D12RootSignature *);
    void (__stdcall *SetComputeRootDescriptorTable)(ID3D12GraphicsCommandList *, U32, D3D12_GPU_DESCRIPTOR_HANDLE);
    void (__stdcall *SetGraphicsRootDescriptorTable)(ID3D12GraphicsCommandList *, U32, D3D12_GPU_DESCRIPTOR_HANDLE);
    void (__stdcall *SetComputeRoot32BitConstant)(ID3D12GraphicsCommandList *, U32, U32, U32);
    void (__stdcall *SetGraphicsRoot32BitConstant)(ID3D12GraphicsCommandList *, U32, U32, U32);
    void (__stdcall *SetComputeRoot32BitConstants)(ID3D12GraphicsCommandList *, U32, U32, const void *, U32);
    void (__stdcall *SetGraphicsRoot32BitConstants)(ID3D12GraphicsCommandList *, U32, U32, const void *, U32);
    void (__stdcall *SetComputeRootConstantBufferView)(ID3D12GraphicsCommandList *, U32, D3D12_GPU_VIRTUAL_ADDRESS);
    void (__stdcall *SetGraphicsRootConstantBufferView)(ID3D12GraphicsCommandList *, U32, D3D12_GPU_VIRTUAL_ADDRESS);
    void (__stdcall *SetComputeRootShaderResourceView)(ID3D12GraphicsCommandList *, U32, D3D12_GPU_VIRTUAL_ADDRESS);
    void (__stdcall *SetGraphicsRootShaderResourceView)(ID3D12GraphicsCommandList *, U32, D3D12_GPU_VIRTUAL_ADDRESS);
    void (__stdcall *SetComputeRootUnorderedAccessView)(ID3D12GraphicsCommandList *, U32, D3D12_GPU_VIRTUAL_ADDRESS);
    void (__stdcall *SetGraphicsRootUnorderedAccessView)(ID3D12GraphicsCommandList *, U32, D3D12_GPU_VIRTUAL_ADDRESS);
    void (__stdcall *IASetIndexBuffer)(ID3D12GraphicsCommandList *, const D3D12_INDEX_BUFFER_VIEW *);
    void (__stdcall *IASetVertexBuffers)(ID3D12GraphicsCommandList *, U32, U32, const D3D12_VERTEX_BUFFER_VIEW *);
    void (__stdcall *SOSetTargets)(ID3D12GraphicsCommandList *, U32, U32, const D3D12_STREAM_OUTPUT_BUFFER_VIEW *);
    void (__stdcall *OMSetRenderTargets)(ID3D12GraphicsCommandList *, U32, const D3D12_CPU_DESCRIPTOR_HANDLE *, S32, const D3D12_CPU_DESCRIPTOR_HANDLE *);
    void (__stdcall *ClearDepthStencilView)(ID3D12GraphicsCommandList *, D3D12_CPU_DESCRIPTOR_HANDLE, D3D12_CLEAR_FLAGS, F32, U8, U32, const D3D12_RECT *);
    void (__stdcall *ClearRenderTargetView)(ID3D12GraphicsCommandList *, D3D12_CPU_DESCRIPTOR_HANDLE, const F32 [4], U32, const D3D12_RECT *);
    void (__stdcall *ClearUnorderedAccessViewUint)(ID3D12GraphicsCommandList *, D3D12_GPU_DESCRIPTOR_HANDLE, D3D12_CPU_DESCRIPTOR_HANDLE, ID3D12Resource *, const U32 [4], U32, const D3D12_RECT *);
    void (__stdcall *ClearUnorderedAccessViewFloat)(ID3D12GraphicsCommandList *, D3D12_GPU_DESCRIPTOR_HANDLE, D3D12_CPU_DESCRIPTOR_HANDLE, ID3D12Resource *, const F32 [4], U32, const D3D12_RECT *);
    void (__stdcall *DiscardResource)(ID3D12GraphicsCommandList *, ID3D12Resource *, const D3D12_DISCARD_REGION *);
    void (__stdcall *BeginQuery)(ID3D12GraphicsCommandList *, ID3D12QueryHeap *, D3D12_QUERY_TYPE, U32);
    void (__stdcall *EndQuery)(ID3D12GraphicsCommandList *, ID3D12QueryHeap *, D3D12_QUERY_TYPE, U32);
    void (__stdcall *ResolveQueryData)(ID3D12GraphicsCommandList *, ID3D12QueryHeap *, D3D12_QUERY_TYPE, U32, U32, ID3D12Resource *, U64);
    void (__stdcall *SetPredication)(ID3D12GraphicsCommandList *, ID3D12Resource *, U64, D3D12_PREDICATION_OP);
    void (__stdcall *SetMarker)(ID3D12GraphicsCommandList *, U32, const void *, U32);
    void (__stdcall *BeginEvent)(ID3D12GraphicsCommandList *, U32, const void *, U32);
    void (__stdcall *EndEvent)(ID3D12GraphicsCommandList *);
    void (__stdcall *ExecuteIndirect)(ID3D12GraphicsCommandList *, ID3D12CommandSignature *, U32, ID3D12Resource *, U64, ID3D12Resource *, U64);
} ID3D12GraphicsCommandListVt; struct ID3D12GraphicsCommandList { const ID3D12GraphicsCommandListVt *vt; };

typedef struct ID3D12DeviceVt {
    S32 (__stdcall *QueryInterface)(ID3D12Device *, const GUID *, void **);
    U32 (__stdcall *AddRef)(ID3D12Device *);
    U32 (__stdcall *Release)(ID3D12Device *);
    S32 (__stdcall *GetPrivateData)(ID3D12Device *, const GUID *, U32 *, void *);
    S32 (__stdcall *SetPrivateData)(ID3D12Device *, const GUID *, U32, const void *);
    S32 (__stdcall *SetPrivateDataInterface)(ID3D12Device *, const GUID *, const IUnknown *);
    S32 (__stdcall *SetName)(ID3D12Device *, const U16 *);
    U32 (__stdcall *GetNodeCount)(ID3D12Device *);
    S32 (__stdcall *CreateCommandQueue)(ID3D12Device *, const D3D12_COMMAND_QUEUE_DESC *, const GUID *, void **);
    S32 (__stdcall *CreateCommandAllocator)(ID3D12Device *, D3D12_COMMAND_LIST_TYPE, const GUID *, void **);
    S32 (__stdcall *CreateGraphicsPipelineState)(ID3D12Device *, const D3D12_GRAPHICS_PIPELINE_STATE_DESC *, const GUID *, void **);
    S32 (__stdcall *CreateComputePipelineState)(ID3D12Device *, const D3D12_COMPUTE_PIPELINE_STATE_DESC *, const GUID *, void **);
    S32 (__stdcall *CreateCommandList)(ID3D12Device *, U32, D3D12_COMMAND_LIST_TYPE, ID3D12CommandAllocator *, ID3D12PipelineState *, const GUID *, void **);
    S32 (__stdcall *CheckFeatureSupport)(ID3D12Device *, D3D12_FEATURE, void *, U32);
    S32 (__stdcall *CreateDescriptorHeap)(ID3D12Device *, const D3D12_DESCRIPTOR_HEAP_DESC *, const GUID *, void **);
    U32 (__stdcall *GetDescriptorHandleIncrementSize)(ID3D12Device *, D3D12_DESCRIPTOR_HEAP_TYPE);
    S32 (__stdcall *CreateRootSignature)(ID3D12Device *, U32, const void *, U64, const GUID *, void **);
    void (__stdcall *CreateConstantBufferView)(ID3D12Device *, const D3D12_CONSTANT_BUFFER_VIEW_DESC *, D3D12_CPU_DESCRIPTOR_HANDLE);
    void (__stdcall *CreateShaderResourceView)(ID3D12Device *, ID3D12Resource *, const D3D12_SHADER_RESOURCE_VIEW_DESC *, D3D12_CPU_DESCRIPTOR_HANDLE);
    void (__stdcall *CreateUnorderedAccessView)(ID3D12Device *, ID3D12Resource *, ID3D12Resource *, const D3D12_UNORDERED_ACCESS_VIEW_DESC *, D3D12_CPU_DESCRIPTOR_HANDLE);
    void (__stdcall *CreateRenderTargetView)(ID3D12Device *, ID3D12Resource *, const D3D12_RENDER_TARGET_VIEW_DESC *, D3D12_CPU_DESCRIPTOR_HANDLE);
    void (__stdcall *CreateDepthStencilView)(ID3D12Device *, ID3D12Resource *, const D3D12_DEPTH_STENCIL_VIEW_DESC *, D3D12_CPU_DESCRIPTOR_HANDLE);
    void (__stdcall *CreateSampler)(ID3D12Device *, const D3D12_SAMPLER_DESC *, D3D12_CPU_DESCRIPTOR_HANDLE);
    void (__stdcall *CopyDescriptors)(ID3D12Device *, U32, const D3D12_CPU_DESCRIPTOR_HANDLE *, const U32 *, U32, const D3D12_CPU_DESCRIPTOR_HANDLE *, const U32 *, D3D12_DESCRIPTOR_HEAP_TYPE);
    void (__stdcall *CopyDescriptorsSimple)(ID3D12Device *, U32, D3D12_CPU_DESCRIPTOR_HANDLE, D3D12_CPU_DESCRIPTOR_HANDLE, D3D12_DESCRIPTOR_HEAP_TYPE);
    D3D12_RESOURCE_ALLOCATION_INFO *(__stdcall *GetResourceAllocationInfo)(ID3D12Device *, U32, U32, const D3D12_RESOURCE_DESC *, D3D12_RESOURCE_ALLOCATION_INFO *);
    D3D12_HEAP_PROPERTIES *(__stdcall *GetCustomHeapProperties)(ID3D12Device *, U32, D3D12_HEAP_TYPE, D3D12_HEAP_PROPERTIES *);
    S32 (__stdcall *CreateCommittedResource)(ID3D12Device *, const D3D12_HEAP_PROPERTIES *, D3D12_HEAP_FLAGS, const D3D12_RESOURCE_DESC *, D3D12_RESOURCE_STATES, const D3D12_CLEAR_VALUE *, const GUID *, void **);
    S32 (__stdcall *CreateHeap)(ID3D12Device *, const D3D12_HEAP_DESC *, const GUID *, void **);
    S32 (__stdcall *CreatePlacedResource)(ID3D12Device *, ID3D12Heap *, U64, const D3D12_RESOURCE_DESC *, D3D12_RESOURCE_STATES, const D3D12_CLEAR_VALUE *, const GUID *, void **);
    S32 (__stdcall *CreateReservedResource)(ID3D12Device *, const D3D12_RESOURCE_DESC *, D3D12_RESOURCE_STATES, const D3D12_CLEAR_VALUE *, const GUID *, void **);
    S32 (__stdcall *CreateSharedHandle)(ID3D12Device *, ID3D12DeviceChild *, const SECURITY_ATTRIBUTES *, U32, U16 *, void **);
    S32 (__stdcall *OpenSharedHandle)(ID3D12Device *, void *, const GUID *, void **);
    S32 (__stdcall *OpenSharedHandleByName)(ID3D12Device *, U16 *, U32, void **);
    S32 (__stdcall *MakeResident)(ID3D12Device *, U32, ID3D12Pageable *const *);
    S32 (__stdcall *Evict)(ID3D12Device *, U32, ID3D12Pageable *const *);
    S32 (__stdcall *CreateFence)(ID3D12Device *, U64, D3D12_FENCE_FLAGS, const GUID *, void **);
    S32 (__stdcall *GetDeviceRemovedReason)(ID3D12Device *);
    void (__stdcall *GetCopyableFootprints)(ID3D12Device *, const D3D12_RESOURCE_DESC *, U32, U32, U64, D3D12_PLACED_SUBRESOURCE_FOOTPRINT *, U32 *, U64 *, U64 *);
    S32 (__stdcall *CreateQueryHeap)(ID3D12Device *, const D3D12_QUERY_HEAP_DESC *, const GUID *, void **);
    S32 (__stdcall *SetStablePowerState)(ID3D12Device *, B32);
    S32 (__stdcall *CreateCommandSignature)(ID3D12Device *, const D3D12_COMMAND_SIGNATURE_DESC *, ID3D12RootSignature *, const GUID *, void **);
    void (__stdcall *GetResourceTiling)(ID3D12Device *, ID3D12Resource *, U32 *, D3D12_PACKED_MIP_INFO *, D3D12_TILE_SHAPE *, U32 *, U32, D3D12_SUBRESOURCE_TILING *);
    S64 (__stdcall *GetAdapterLuid)(ID3D12Device *);
} ID3D12DeviceVt; struct ID3D12Device { const ID3D12DeviceVt *vt; };

static S32 (__stdcall *D3D12CreateDevice)(IUnknown *, D3D_FEATURE_LEVEL, const GUID *, void **);
static S32 (__stdcall *D3D12GetDebugInterface)(const GUID *, void **);

static const GUID IID_ID3D12Debug = { 0x344488b7,0x6846,0x474b,0xb9,0x89,0xf0,0x27,0x44,0x82,0x45,0xe0 };
static const GUID IID_IDXGISwapChain = { 0x310d36a0,0xd2e7,0x4c0a,0xaa,0x04,0x6a,0x9d,0x23,0xb8,0x88,0x6a };
static const GUID IID_IDXGISwapChain3 = { 0x94d99bdb,0xf1f8,0x4ab0,0xb2,0x36,0x7d,0xa0,0x17,0x0e,0xda,0xb1 };
static const GUID IID_IDXGIFactory4 = { 0x1bc6ea02,0xef36,0x464f,0xbf,0x0c,0x21,0xca,0x39,0xe5,0x16,0x8a };
static const GUID IID_ID3D12GraphicsCommandList = { 0x5b160d0f,0xac1b,0x4185,0x8b,0xa8,0xb3,0xae,0x42,0xa5,0xa4,0x55 };
static const GUID IID_ID3D12CommandQueue = { 0x0ec870a6,0x5d7e,0x4c22,0x8c,0xfc,0x5b,0xaa,0xe0,0x76,0x16,0xed };
static const GUID IID_ID3D12Device = { 0x189819f1,0x1db6,0x4b57,0xbe,0x54,0x18,0x21,0x33,0x9b,0x85,0xf7 };
static const GUID IID_ID3D12DescriptorHeap = { 0x8efb471d,0x616c,0x4f49,0x90,0xf7,0x12,0x7b,0xb7,0x63,0xfa,0x51 };
static const GUID IID_ID3D12Resource = { 0x696442be,0xa72e,0x4059,0xbc,0x79,0x5b,0x5c,0x98,0x04,0x0f,0xad };
static const GUID IID_ID3D12RootSignature = { 0xc54a6b66,0x72df,0x4ee8,0x8b,0xe5,0xa9,0x46,0xa1,0x42,0x92,0x14 };
static const GUID IID_ID3D12CommandAllocator = { 0x6102dee4,0xaf59,0x4b09,0xb9,0x99,0xb4,0x4d,0x73,0xf0,0x9b,0x24 };
static const GUID IID_ID3D12Fence = { 0x0a753dcf,0xc4d8,0x4b91,0xad,0xf6,0xbe,0x5a,0x60,0xd9,0x5a,0x76 };
static const GUID IID_ID3D12PipelineState = { 0x765a30f3,0xf624,0x4c6f,0xa8,0x28,0xac,0xe9,0x48,0x62,0x24,0x45 };
//-------------------------------------------------------------------------------------------------
// Math
//-------------------------------------------------------------------------------------------------
#define KPi 3.141592654f
#define K2Pi 6.283185307f
#define K1DivPi 0.318309886f
#define K1Div2Pi 0.159154943f
#define KPiDiv2 1.570796327f
#define KPiDiv4 0.785398163f

// Needed for F32Sqrt
typedef union __declspec(intrin_type) __declspec(align(16)) __m128 { float m128_f32[4]; unsigned __int64 m128_u64[2]; __int8 m128_i8[16]; __int16 m128_i16[8]; __int32 m128_i32[4]; __int64 m128_i64[2]; unsigned __int8 m128_u8[16]; unsigned __int16 m128_u16[8]; unsigned __int32 m128_u32[4]; } __m128;
extern __m128 _mm_sqrt_ss(__m128); extern __m128 _mm_load_ss(float const *); extern void _mm_store_ss(float *, __m128);

typedef struct Vec3 { F32 x, y, z; } Vec3;
typedef struct Vec4 { F32 x, y, z, w; } Vec4;
typedef struct Mat4 { Vec4 r[4]; } Mat4;

static inline F32 F32Abs(F32 x) { union { F32 f; U32 u; } fu; fu.f = x; fu.u &= 0x7fffffff; return fu.f; }
static inline B32 F32Equal(F32 a, F32 b, F32 epsilon) { return F32Abs(a - b) <= epsilon; }
static inline U32 U32Rand(U32 *state) { assert(state); *state = *state * 1103515245 + 12345; return (*state >> 16) & 0x7fff; }
static inline F32 F32Rand(U32 *state) { U32 result = (127 << 23) | (U32Rand(state) << 8); return *(F32 *)&result - 1.0f; }
static inline F32 F32RandRange(U32 *state, F32 begin, F32 end) { assert(begin < end); return begin + (end - begin) * F32Rand(state); }
static inline F32 F32Sqrt(F32 x) { __m128 xv = _mm_load_ss(&x); xv = _mm_sqrt_ss(xv); _mm_store_ss(&x, xv); return x; }

static inline F32 _F32PreSin(F32 x)
{
    F32 quotient = K1Div2Pi * x;
    quotient = x >= 0.0f ? (F32)((S32)(quotient + 0.5f)) : (F32)((S32)(quotient - 0.5f));
    F32 y = x - K2Pi * quotient;
    if (y > KPiDiv2) {
        y = KPi - y;
    } else if (y < -KPiDiv2) {
        y = -KPi - y;
    }
    return y;
}
static inline F32 _F32PreCos(F32 x, F32 *sign)
{
    assert(sign);
    F32 quotient = K1Div2Pi * x;
    quotient = x >= 0.0f ? (F32)((S32)(quotient + 0.5f)) : (F32)((S32)(quotient - 0.5f));
    F32 y = x - K2Pi * quotient;
    if (y > KPiDiv2) {
        y = KPi - y;
        *sign = -1.0f;
    } else if (y < -KPiDiv2) {
        y = -KPi - y;
        *sign = -1.0f;
    } else {
        *sign = 1.0f;
    }
    return y;
}
static F32 F32Sin(F32 x)
{
    F32 y = _F32PreSin(x);
    F32 y2 = y * y;
    return (((((-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f) * y2 + 0.0083333310f) * y2 - 0.16666667f) * y2 + 1.0f) * y;
}
static F32 F32SinFast(F32 x)
{
    F32 y = _F32PreSin(x);
    F32 y2 = y * y;
    return (((-0.00018524670f * y2 + 0.0083139502f) * y2 - 0.16665852f) * y2 + 1.0f) * y;
}
static F32 F32Cos(F32 x)
{
    F32 sign;
    F32 y = _F32PreCos(x, &sign);
    F32 y2 = y * y;
    return sign * (((((-2.6051615e-07f * y2 + 2.4760495e-05f) * y2 - 0.0013888378f) * y2 + 0.041666638f) * y2 - 0.5f) * y2 + 1.0f);
}
static F32 F32CosFast(F32 x)
{
    F32 sign;
    F32 y = _F32PreCos(x, &sign);
    F32 y2 = y * y;
    return sign * (((-0.0012712436f * y2 + 0.041493919f) * y2 - 0.49992746f) * y2 + 1.0f);
}
static void F32SinCos(F32 *sinOut, F32 *cosOut, F32 x)
{
    assert(sinOut && cosOut);
    F32 sign;
    F32 y = _F32PreCos(x, &sign);
    F32 y2 = y * y;
    *sinOut = (((((-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f) * y2 + 0.0083333310f) * y2 - 0.16666667f) * y2 + 1.0f) * y;
    *cosOut = sign * (((((-2.6051615e-07f * y2 + 2.4760495e-05f) * y2 - 0.0013888378f) * y2 + 0.041666638f) * y2 - 0.5f) * y2 + 1.0f);
}
static void F32SinCosFast(F32 *sinOut, F32 *cosOut, F32 x)
{
    assert(sinOut && cosOut);
    F32 sign;
    F32 y = _F32PreCos(x, &sign);
    F32 y2 = y * y;
    *sinOut = (((-0.00018524670f * y2 + 0.0083139502f) * y2 - 0.16665852f) * y2 + 1.0f) * y;
    *cosOut = sign * (((-0.0012712436f * y2 + 0.041493919f) * y2 - 0.49992746f) * y2 + 1.0f);
}

static inline Vec3 *Vec3Set(Vec3 *out, F32 x, F32 y, F32 z)
{
    out->x = x; out->y = y; out->z = z; return out;
}
static inline Vec3 *Vec3Add(Vec3 *out, const Vec3 *a, const Vec3 *b)
{
    out->x = a->x + b->x; out->y = a->y + b->y; out->z = a->z + b->z; return out;
}
static inline Vec3 *Vec3Sub(Vec3 *out, const Vec3 *a, const Vec3 *b)
{
    out->x = a->x - b->x; out->y = a->y - b->y; out->z = a->z - b->z; return out;
}
static inline Vec3 *Vec3Neg(Vec3 *out, const Vec3 *a)
{
    out->x = -a->x; out->y = -a->y; out->z = -a->z; return out;
}
static inline Vec4 *Vec4Set(Vec4 *out, F32 x, F32 y, F32 z, F32 w)
{
    out->x = x; out->y = y; out->z = z; out->w = w; return out;
}
static inline F32 Vec3Dot(const Vec3 *a, const Vec3 *b)
{
    return a->x * b->x + a->y * b->y + a->z * b->z;
}
static inline Vec3 *Vec3Cross(Vec3 *out, const Vec3 *a, const Vec3 *b)
{
    F32 x = a->y * b->z - a->z * b->y;
    F32 y = a->z * b->x - a->x * b->z;
    F32 z = a->x * b->y - a->y * b->x;
    return Vec3Set(out, x, y, z);
}
static inline F32 Vec3Length(const Vec3 *a) { return F32Sqrt(Vec3Dot(a, a)); }
static inline Vec3 *Vec3Normalize(Vec3 *out, const Vec3 *a)
{
    F32 length = Vec3Length(a);
    assert(!F32Equal(length, 0.0f, 0.0001f));
    F32 rcplen = 1.0f / length;
    return Vec3Set(out, rcplen * a->x, rcplen * a->y, rcplen * a->z);
}

static inline Mat4 *Mat4SetPerspective(Mat4 *out, F32 fovy, F32 aspect, F32 n, F32 f)
{
    F32 sinfov, cosfov;
    F32SinCos(&sinfov, &cosfov, 0.5f * fovy);
    F32 h = cosfov / sinfov;
    F32 w = h / aspect;
    F32 r = f / (f - n);
    Vec4Set(&out->r[0], w, 0.0f, 0.0f, 0.0f);
    Vec4Set(&out->r[1], 0.0f, h, 0.0f, 0.0f);
    Vec4Set(&out->r[2], 0.0f, 0.0f, r, 1.0f);
    Vec4Set(&out->r[3], 0.0f, 0.0f, -r * n, 0.0f);
    return out;
}
static inline Mat4 *Mat4Transpose(Mat4 *out, const Mat4 *a)
{
    Mat4 result;
    result.r[0].x = a->r[0].x; result.r[1].x = a->r[0].y; result.r[2].x = a->r[0].z; result.r[3].x = a->r[0].w;
    result.r[0].y = a->r[1].x; result.r[1].y = a->r[1].y; result.r[2].y = a->r[1].z; result.r[3].y = a->r[1].w;
    result.r[0].z = a->r[2].x; result.r[1].z = a->r[2].y; result.r[2].z = a->r[2].z; result.r[3].z = a->r[2].w;
    result.r[0].w = a->r[3].x; result.r[1].w = a->r[3].y; result.r[2].w = a->r[3].z; result.r[3].w = a->r[3].w;
    *out = result;
    return out;
}
static inline Mat4 *Mat4Mul(Mat4 *out, const Mat4 *a, const Mat4 *b)
{
    Mat4 result;
    result.r[0].x = a->r[0].x * b->r[0].x + a->r[0].y * b->r[1].x + a->r[0].z * b->r[2].x + a->r[0].w * b->r[3].x;
    result.r[0].y = a->r[0].x * b->r[0].y + a->r[0].y * b->r[1].y + a->r[0].z * b->r[2].y + a->r[0].w * b->r[3].y;
    result.r[0].z = a->r[0].x * b->r[0].z + a->r[0].y * b->r[1].z + a->r[0].z * b->r[2].z + a->r[0].w * b->r[3].z;
    result.r[0].w = a->r[0].x * b->r[0].w + a->r[0].y * b->r[1].w + a->r[0].z * b->r[2].w + a->r[0].w * b->r[3].w;
    result.r[1].x = a->r[1].x * b->r[0].x + a->r[1].y * b->r[1].x + a->r[1].z * b->r[2].x + a->r[1].w * b->r[3].x;
    result.r[1].y = a->r[1].x * b->r[0].y + a->r[1].y * b->r[1].y + a->r[1].z * b->r[2].y + a->r[1].w * b->r[3].y;
    result.r[1].z = a->r[1].x * b->r[0].z + a->r[1].y * b->r[1].z + a->r[1].z * b->r[2].z + a->r[1].w * b->r[3].z;
    result.r[1].w = a->r[1].x * b->r[0].w + a->r[1].y * b->r[1].w + a->r[1].z * b->r[2].w + a->r[1].w * b->r[3].w;
    result.r[2].x = a->r[2].x * b->r[0].x + a->r[2].y * b->r[1].x + a->r[2].z * b->r[2].x + a->r[2].w * b->r[3].x;
    result.r[2].y = a->r[2].x * b->r[0].y + a->r[2].y * b->r[1].y + a->r[2].z * b->r[2].y + a->r[2].w * b->r[3].y;
    result.r[2].z = a->r[2].x * b->r[0].z + a->r[2].y * b->r[1].z + a->r[2].z * b->r[2].z + a->r[2].w * b->r[3].z;
    result.r[2].w = a->r[2].x * b->r[0].w + a->r[2].y * b->r[1].w + a->r[2].z * b->r[2].w + a->r[2].w * b->r[3].w;
    result.r[3].x = a->r[3].x * b->r[0].x + a->r[3].y * b->r[1].x + a->r[3].z * b->r[2].x + a->r[3].w * b->r[3].x;
    result.r[3].y = a->r[3].x * b->r[0].y + a->r[3].y * b->r[1].y + a->r[3].z * b->r[2].y + a->r[3].w * b->r[3].y;
    result.r[3].z = a->r[3].x * b->r[0].z + a->r[3].y * b->r[1].z + a->r[3].z * b->r[2].z + a->r[3].w * b->r[3].z;
    result.r[3].w = a->r[3].x * b->r[0].w + a->r[3].y * b->r[1].w + a->r[3].z * b->r[2].w + a->r[3].w * b->r[3].w;
    *out = result;
    return out;
}
//-------------------------------------------------------------------------------------------------
// Library
//-------------------------------------------------------------------------------------------------
static void *LibMalloc(U64 size)
{
    assert(size > 0);
    void *mem = HeapAlloc(GetProcessHeap(), 0, size);
    if (!mem) {
        OutputDebugString("Failed to allocate memory!");
        assert(0);
        ExitProcess(1);
    }
    return mem;
}

static void *LibRealloc(void *addr, U64 size)
{
    assert(size > 0);
    if (addr == NULL) {
        return LibMalloc(size);
    } else {
        void *mem = HeapReAlloc(GetProcessHeap(), 0, addr, size);
        if (!mem) {
            OutputDebugString("Failed to reallocate memory!");
            assert(0);
            ExitProcess(1);
        }
        return mem;
    }
}

static void LibFree(void *addr)
{
    assert(addr);
    if (!HeapFree(GetProcessHeap(), 0, addr)) {
        OutputDebugString("Failed to free memory!");
        assert(0);
        ExitProcess(1);
    }
}

static void *LibLoadFile(const char *filename, U32 *fileSizeOut)
{
    assert(filename && fileSizeOut);
    void *handle = CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    assert(handle != (void *)-1);
    U32 size = GetFileSize(handle, NULL);
    char *content = (char *)LibMalloc(size);
    U32 bytesRead;
    ReadFile(handle, content, size, &bytesRead, NULL);
    CloseHandle(handle);
    assert(bytesRead == size);
    *fileSizeOut = size;
    return content;
}

static F64 LibGetTime(void)
{
    static S64 frequency, startCounter;
    if (frequency == 0) {
        QueryPerformanceCounter(&startCounter);
        QueryPerformanceFrequency(&frequency);
    }
    S64 counter;
    QueryPerformanceCounter(&counter);
    return (counter - startCounter) / (F64)frequency;
}

static void LibUpdateFrameStats(void *window, const char *name, F64 *timeOut, F32 *deltaTimeOut)
{
    static F64 prevTime;
    static F64 prevHeaderUpdateTime;
    static U32 frameCount;

    if (prevTime == 0.0) {
        prevTime = LibGetTime();
        prevHeaderUpdateTime = prevTime;
    }

    *timeOut = LibGetTime();
    *deltaTimeOut = (F32)(*timeOut - prevTime);
    prevTime = *timeOut;

    if ((*timeOut - prevHeaderUpdateTime) >= 1.0) {
        F64 fps = frameCount / (*timeOut - prevHeaderUpdateTime);
        F64 us = (1.0 / fps) * 1000000.0;
        char text[256];
        wsprintf(text, "[%d fps  %d us] %s", (S32)fps, (S32)us, name);
        SetWindowText(window, text);
        prevHeaderUpdateTime = *timeOut;
        frameCount = 0;
    }
    frameCount++;
}

static S64 __stdcall _LibProcessWindowMessage(void *window, U32 message, U64 wparam, S64 lparam)
{
    switch (message) {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    case WM_KEYDOWN:
        if (wparam == VK_ESCAPE) {
            PostQuitMessage(0);
            return 0;
        }
        break;
    }
    return DefWindowProc(window, message, wparam, lparam);
}

static void *LibCreateWindow(const char *name, U32 width, U32 height)
{
    WNDCLASS winclass = {
        .lpfnWndProc = _LibProcessWindowMessage,
        .hInstance = GetModuleHandle(NULL),
        .hCursor = LoadCursor(NULL, IDC_ARROW),
        .lpszClassName = name,
    };
    if (!RegisterClass(&winclass))
        assert(0);

    RECT rect = { 0, 0, (S32)width, (S32)height };
    if (!AdjustWindowRect(&rect, WS_OVERLAPPED | WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX, 0))
        assert(0);

    void *window = CreateWindowEx(0, name, name, WS_OVERLAPPED | WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX | WS_VISIBLE,
                                  CW_USEDEFAULT, CW_USEDEFAULT,
                                  rect.right - rect.left, rect.bottom - rect.top,
                                  NULL, NULL, NULL, 0);
    assert(window);
    return window;
}

static void LibLoadFunctions(void)
{
    void *kernel32 = LoadLibraryA("kernel32.dll");
    OutputDebugString = GetProcAddress(kernel32, "OutputDebugStringA");
    GetModuleHandle = GetProcAddress(kernel32, "GetModuleHandleA");
    QueryPerformanceCounter = GetProcAddress(kernel32, "QueryPerformanceCounter");
    QueryPerformanceFrequency = GetProcAddress(kernel32, "QueryPerformanceFrequency");
    VirtualAlloc = GetProcAddress(kernel32, "VirtualAlloc");
    VirtualFree = GetProcAddress(kernel32, "VirtualFree");
    ExitProcess = GetProcAddress(kernel32, "ExitProcess");
    CreateFile = GetProcAddress(kernel32, "CreateFileA");
    ReadFile = GetProcAddress(kernel32, "ReadFile");
    GetFileSize = GetProcAddress(kernel32, "GetFileSize");
    CloseHandle = GetProcAddress(kernel32, "CloseHandle");
    Sleep = GetProcAddress(kernel32, "Sleep");
    HeapAlloc = GetProcAddress(kernel32, "HeapAlloc");
    HeapFree = GetProcAddress(kernel32, "HeapFree");
    HeapReAlloc = GetProcAddress(kernel32, "HeapReAlloc");
    GetProcessHeap = GetProcAddress(kernel32, "GetProcessHeap");
    CreateEventEx = GetProcAddress(kernel32, "CreateEventExA");
    WaitForSingleObject = GetProcAddress(kernel32, "WaitForSingleObject");

    void *user32 = LoadLibraryA("user32.dll");
    PeekMessage = GetProcAddress(user32, "PeekMessageA");
    DispatchMessage = GetProcAddress(user32, "DispatchMessageA");
    PostQuitMessage = GetProcAddress(user32, "PostQuitMessage");
    DefWindowProc = GetProcAddress(user32, "DefWindowProcA");
    LoadCursor = GetProcAddress(user32, "LoadCursorA");
    RegisterClass = GetProcAddress(user32, "RegisterClassA");
    CreateWindowEx = GetProcAddress(user32, "CreateWindowExA");
    AdjustWindowRect = GetProcAddress(user32, "AdjustWindowRect");
    wsprintf = GetProcAddress(user32, "wsprintfA");
    SetWindowText = GetProcAddress(user32, "SetWindowTextA");
    SetProcessDPIAware = GetProcAddress(user32, "SetProcessDPIAware");
    GetDC = GetProcAddress(user32, "GetDC");
    MessageBox = GetProcAddress(user32, "MessageBoxA");
    GetClientRect = GetProcAddress(user32, "GetClientRect");

    void *d3d12 = LoadLibraryA("d3d12.dll");
    if (!d3d12) {
        MessageBox(NULL, "Program requires Windows 10 machine with DirectX 12 support (D3D_FEATURE_LEVEL_11_1 or better).", "Error", 0);
        ExitProcess(1);
    }
    D3D12CreateDevice = GetProcAddress(d3d12, "D3D12CreateDevice");
    D3D12GetDebugInterface = GetProcAddress(d3d12, "D3D12GetDebugInterface");

    void *dxgi = LoadLibraryA("dxgi.dll");
    CreateDXGIFactory1 = GetProcAddress(dxgi, "CreateDXGIFactory1");
}
//-------------------------------------------------------------------------------------------------
// Direct3D 12 Subsystem
//-------------------------------------------------------------------------------------------------
struct {
    ID3D12Device *device;
    ID3D12CommandQueue *cmdQueue;
    ID3D12CommandAllocator *cmdAlloc[2];
    ID3D12GraphicsCommandList *cmdList;
    U32 descriptorSize, descriptorSizeRtv;
    U32 frameIndex;
    ID3D12Resource *depthBuffer;
    D3D12_CPU_DESCRIPTOR_HANDLE depthBufferDescriptor;
} Dx;

typedef struct _DxDescriptorHeap {
    ID3D12DescriptorHeap *heap;
    D3D12_CPU_DESCRIPTOR_HANDLE cpuStart;
    D3D12_GPU_DESCRIPTOR_HANDLE gpuStart;
    U32 size;
    U32 capacity;
} _DxDescriptorHeap;

typedef struct _DxGpuMemoryHeap {
    ID3D12Resource *heap;
    U8 *cpuStart;
    D3D12_GPU_VIRTUAL_ADDRESS gpuStart;
    U32 size;
    U32 capacity;
} _DxGpuMemoryHeap;

struct {
    IDXGISwapChain3 *swapchain;
    ID3D12Resource *swapbuffers[4];
    ID3D12Fence *frameFence;
    void *frameFenceEvent;
    U64 frameCount;
    U32 backBufferIndex;
    _DxDescriptorHeap rtvHeap;
    _DxDescriptorHeap dsvHeap;
    _DxDescriptorHeap cbvSrvUavHeap;
    _DxDescriptorHeap cbvSrvUavGpuHeaps[2];
    _DxGpuMemoryHeap uploadMemoryHeaps[2];
} _Dx;

static _DxDescriptorHeap *_DxGetDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE type, D3D12_DESCRIPTOR_HEAP_FLAGS flags, U32 *descriptorSizeOut)
{
    assert(descriptorSizeOut);
    if (type == D3D12_DESCRIPTOR_HEAP_TYPE_RTV) {
        *descriptorSizeOut = Dx.descriptorSizeRtv;
        return &_Dx.rtvHeap;
    } else if (type == D3D12_DESCRIPTOR_HEAP_TYPE_DSV) {
        *descriptorSizeOut = Dx.descriptorSizeRtv;
        return &_Dx.dsvHeap;
    } else if (type == D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV) {
        *descriptorSizeOut = Dx.descriptorSize;
        if (flags == D3D12_DESCRIPTOR_HEAP_FLAG_NONE)
            return &_Dx.cbvSrvUavHeap;
        else if (flags == D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE)
            return &_Dx.cbvSrvUavGpuHeaps[Dx.frameIndex];
    }
    assert(0);
    *descriptorSizeOut = 0;
    return NULL;
}

static void DxAllocateDescriptors(D3D12_DESCRIPTOR_HEAP_TYPE type, U32 count, D3D12_CPU_DESCRIPTOR_HANDLE *firstOut)
{
    assert(firstOut);
    U32 descriptorSize;
    _DxDescriptorHeap *heap = _DxGetDescriptorHeap(type, D3D12_DESCRIPTOR_HEAP_FLAG_NONE, &descriptorSize);
    assert((heap->size + count) < heap->capacity);
    firstOut->ptr = heap->cpuStart.ptr + heap->size * descriptorSize;
    heap->size += count;
}

static void DxPresent(void)
{
    _Dx.swapchain->vt->Present(_Dx.swapchain, 0, 0);
    Dx.cmdQueue->vt->Signal(Dx.cmdQueue, _Dx.frameFence, ++_Dx.frameCount);

    U64 gpuFrameCount = _Dx.frameFence->vt->GetCompletedValue(_Dx.frameFence);

    if ((_Dx.frameCount - gpuFrameCount) >= 2) {
        _Dx.frameFence->vt->SetEventOnCompletion(_Dx.frameFence, gpuFrameCount + 1, _Dx.frameFenceEvent);
        WaitForSingleObject(_Dx.frameFenceEvent, INFINITE);
    }
    Dx.frameIndex = !Dx.frameIndex;
    _Dx.backBufferIndex = _Dx.swapchain->vt->GetCurrentBackBufferIndex(_Dx.swapchain);

    _Dx.cbvSrvUavGpuHeaps[Dx.frameIndex].size = 0;
    _Dx.uploadMemoryHeaps[Dx.frameIndex].size = 0;
}

static void DxWaitForGpu(void)
{
    Dx.cmdQueue->vt->Signal(Dx.cmdQueue, _Dx.frameFence, ++_Dx.frameCount);
    _Dx.frameFence->vt->SetEventOnCompletion(_Dx.frameFence, _Dx.frameCount, _Dx.frameFenceEvent);
    WaitForSingleObject(_Dx.frameFenceEvent, INFINITE);
}

static inline void DxGetBackBuffer(ID3D12Resource **resourceOut, D3D12_CPU_DESCRIPTOR_HANDLE *descriptorOut)
{
    assert(resourceOut && descriptorOut);
    *resourceOut = _Dx.swapbuffers[_Dx.backBufferIndex];
    *descriptorOut = _Dx.rtvHeap.cpuStart;
    descriptorOut->ptr += _Dx.backBufferIndex * Dx.descriptorSizeRtv;
}

static inline void DxSetDescriptorHeap(void)
{
    Dx.cmdList->vt->SetDescriptorHeaps(Dx.cmdList, 1, &_Dx.cbvSrvUavGpuHeaps[Dx.frameIndex].heap);
}

static void DxInit(void *window)
{
    IDXGIFactory *factory;
    VHR(CreateDXGIFactory1(&IID_IDXGIFactory4, &factory));
#ifdef _DEBUG
    ID3D12Debug *dbg = NULL;
    D3D12GetDebugInterface(&IID_ID3D12Debug, &dbg);
    if (dbg) {
        dbg->vt->EnableDebugLayer(dbg);
        dbg->vt->Release(dbg);
    }
#endif
    if (D3D12CreateDevice(NULL, D3D_FEATURE_LEVEL_11_1, &IID_ID3D12Device, &Dx.device) != 0) {
        MessageBox(window, "Program requires Windows 10 machine with DirectX 12 support (D3D_FEATURE_LEVEL_11_1 or better).", "Error", 0);
        ExitProcess(1);
    }
    D3D12_COMMAND_QUEUE_DESC cmdQueueDesc = { .Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL, .Type = D3D12_COMMAND_LIST_TYPE_DIRECT };
    VHR(Dx.device->vt->CreateCommandQueue(Dx.device, &cmdQueueDesc, &IID_ID3D12CommandQueue, &Dx.cmdQueue));

    DXGI_SWAP_CHAIN_DESC swapchainDesc = {
        .BufferCount = 4,
        .BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM,
        .BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT,
        .OutputWindow = window,
        .SampleDesc.Count = 1,
        .SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL,
        .Windowed = TRUE };
    IUnknown *swapchain;
    VHR(factory->vt->CreateSwapChain(factory, (IUnknown *)Dx.cmdQueue, &swapchainDesc, (IDXGISwapChain **)&swapchain));
    VHR(swapchain->vt->QueryInterface(swapchain, &IID_IDXGISwapChain3, &_Dx.swapchain));
    swapchain->vt->Release(swapchain);
    factory->vt->Release(factory);

    RECT winrect;
    GetClientRect(window, &winrect);

    for (U32 i = 0; i < 2; ++i)
        VHR(Dx.device->vt->CreateCommandAllocator(Dx.device, D3D12_COMMAND_LIST_TYPE_DIRECT, &IID_ID3D12CommandAllocator, &Dx.cmdAlloc[i]));

    Dx.descriptorSize = Dx.device->vt->GetDescriptorHandleIncrementSize(Dx.device, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
    Dx.descriptorSizeRtv = Dx.device->vt->GetDescriptorHandleIncrementSize(Dx.device, D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

    /* RTV heap */ {
        _Dx.rtvHeap.size = 0;
        _Dx.rtvHeap.capacity = 16;
        _Dx.rtvHeap.cpuStart.ptr = 0;
        _Dx.rtvHeap.gpuStart.ptr = 0;

        D3D12_DESCRIPTOR_HEAP_DESC heapDesc = { .NumDescriptors = _Dx.rtvHeap.capacity, .Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV };
        VHR(Dx.device->vt->CreateDescriptorHeap(Dx.device, &heapDesc, &IID_ID3D12DescriptorHeap, &_Dx.rtvHeap.heap));
        _Dx.rtvHeap.heap->vt->GetCPUDescriptorHandleForHeapStart(_Dx.rtvHeap.heap, &_Dx.rtvHeap.cpuStart);
    }
    /* DSV heap */ {
        _Dx.dsvHeap.size = 0;
        _Dx.dsvHeap.capacity = 8;
        _Dx.dsvHeap.cpuStart.ptr = 0;
        _Dx.dsvHeap.gpuStart.ptr = 0;

        D3D12_DESCRIPTOR_HEAP_DESC heapDesc = { .NumDescriptors = _Dx.dsvHeap.capacity, .Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV };
        VHR(Dx.device->vt->CreateDescriptorHeap(Dx.device, &heapDesc, &IID_ID3D12DescriptorHeap, &_Dx.dsvHeap.heap));
        _Dx.dsvHeap.heap->vt->GetCPUDescriptorHandleForHeapStart(_Dx.dsvHeap.heap, &_Dx.dsvHeap.cpuStart);
    }
    /* CBV_SRV_UAV heap */ {
        _Dx.cbvSrvUavHeap.size = 0;
        _Dx.cbvSrvUavHeap.capacity = 10000;
        _Dx.cbvSrvUavHeap.cpuStart.ptr = 0;
        _Dx.cbvSrvUavHeap.gpuStart.ptr = 0;

        D3D12_DESCRIPTOR_HEAP_DESC heapDesc = { .NumDescriptors = _Dx.cbvSrvUavHeap.capacity, .Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV };
        VHR(Dx.device->vt->CreateDescriptorHeap(Dx.device, &heapDesc, &IID_ID3D12DescriptorHeap, &_Dx.cbvSrvUavHeap.heap));
        _Dx.cbvSrvUavHeap.heap->vt->GetCPUDescriptorHandleForHeapStart(_Dx.cbvSrvUavHeap.heap, &_Dx.cbvSrvUavHeap.cpuStart);
    }
    /* CBV_SRV_UAV shader visible heaps */ {
        for (U32 i = 0; i < 2; ++i) {
            _DxDescriptorHeap *heap = &_Dx.cbvSrvUavGpuHeaps[i];
            heap->size = 0;
            heap->capacity = 10000;
            heap->cpuStart.ptr = 0;
            heap->gpuStart.ptr = 0;

            D3D12_DESCRIPTOR_HEAP_DESC heapDesc = {
                .NumDescriptors = heap->capacity,
                .Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
                .Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE };
            VHR(Dx.device->vt->CreateDescriptorHeap(Dx.device, &heapDesc, &IID_ID3D12DescriptorHeap, &heap->heap));
            heap->heap->vt->GetCPUDescriptorHandleForHeapStart(heap->heap, &heap->cpuStart);
            heap->heap->vt->GetGPUDescriptorHandleForHeapStart(heap->heap, &heap->gpuStart);
        }
    }
    /* GPU upload memory heaps */ {
        for (U32 i = 0; i < 2; ++i) {
            _DxGpuMemoryHeap *heap = &_Dx.uploadMemoryHeaps[i];
            heap->size = 0;
            heap->capacity = 8*1024*1024;
            heap->cpuStart = 0;
            heap->gpuStart = 0;

            D3D12_HEAP_PROPERTIES heapProps = { .Type = D3D12_HEAP_TYPE_UPLOAD, .CreationNodeMask = 1, .VisibleNodeMask = 1 };
            D3D12_RESOURCE_DESC resourceDesc = {
                .Dimension = D3D12_RESOURCE_DIMENSION_BUFFER,
                .Width = heap->capacity,
                .Height = 1,
                .DepthOrArraySize = 1,
                .MipLevels = 1,
                .SampleDesc.Count = 1,
                .Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR };
            VHR(Dx.device->vt->CreateCommittedResource(Dx.device, &heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, NULL, &IID_ID3D12Resource, &heap->heap));

            D3D12_RANGE range = { 0 };
            VHR(heap->heap->vt->Map(heap->heap, 0, &range, &heap->cpuStart));
            heap->gpuStart = heap->heap->vt->GetGPUVirtualAddress(heap->heap);
        }
    }
    /* Swap chain buffers */ {
        D3D12_CPU_DESCRIPTOR_HANDLE handle;
        DxAllocateDescriptors(D3D12_DESCRIPTOR_HEAP_TYPE_RTV, 4, &handle);

        for (U32 i = 0; i < 4; ++i) {
            VHR(_Dx.swapchain->vt->GetBuffer(_Dx.swapchain, i, &IID_ID3D12Resource, &_Dx.swapbuffers[i]));
            Dx.device->vt->CreateRenderTargetView(Dx.device, _Dx.swapbuffers[i], NULL, handle);
            handle.ptr += Dx.descriptorSizeRtv;
        }
    }
    /* Depth buffer */ {
        DXGI_FORMAT format = DXGI_FORMAT_D32_FLOAT;
        D3D12_HEAP_PROPERTIES heapProps = { .Type = D3D12_HEAP_TYPE_DEFAULT, .CreationNodeMask = 1, .VisibleNodeMask = 1 };
        D3D12_RESOURCE_DESC resourceDesc = {
            .Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D,
            .Width = winrect.right,
            .Height = winrect.bottom,
            .DepthOrArraySize = 1,
            .MipLevels = 1,
            .Format = format,
            .SampleDesc.Count = 1,
            .Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL | D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE };
        D3D12_CLEAR_VALUE clearValue = { .Format = format, .DepthStencil.Depth = 1.0f };
        VHR(Dx.device->vt->CreateCommittedResource(Dx.device, &heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_DEPTH_WRITE, &clearValue, &IID_ID3D12Resource, &Dx.depthBuffer));

        DxAllocateDescriptors(D3D12_DESCRIPTOR_HEAP_TYPE_DSV, 1, &Dx.depthBufferDescriptor);

        D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = { .Format = format, .ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D };
        Dx.device->vt->CreateDepthStencilView(Dx.device, Dx.depthBuffer, &dsvDesc, Dx.depthBufferDescriptor);
    }
    VHR(Dx.device->vt->CreateCommandList(Dx.device, 0, D3D12_COMMAND_LIST_TYPE_DIRECT, Dx.cmdAlloc[0], NULL, &IID_ID3D12GraphicsCommandList, &Dx.cmdList));
    VHR(Dx.device->vt->CreateFence(Dx.device, 0, D3D12_FENCE_FLAG_NONE, &IID_ID3D12Fence, &_Dx.frameFence));
    _Dx.frameFenceEvent = CreateEventEx(NULL, NULL, 0, EVENT_ALL_ACCESS);
}
//-------------------------------------------------------------------------------------------------
// Main module
//-------------------------------------------------------------------------------------------------
struct {
    U32 viewportWidth, viewportHeight;
    const char *demoName;
    ID3D12PipelineState *pipelineState;
    ID3D12RootSignature *rootSignature;
} G;

static void Draw(void)
{
    ID3D12CommandAllocator *cmdAlloc = Dx.cmdAlloc[Dx.frameIndex];
    cmdAlloc->vt->Reset(cmdAlloc);

    D3D12_VIEWPORT viewport = { 0.0f, 0.0f, (F32)G.viewportWidth, (F32)G.viewportHeight, 0.0f, 1.0f };
    D3D12_RECT scissor = { 0, 0, G.viewportWidth, G.viewportHeight };
    ID3D12GraphicsCommandList *cmdList = Dx.cmdList;
    cmdList->vt->Reset(cmdList, cmdAlloc, NULL);
    cmdList->vt->RSSetViewports(cmdList, 1, &viewport);
    cmdList->vt->RSSetScissorRects(cmdList, 1, &scissor);

    ID3D12Resource *backBuffer;
    D3D12_CPU_DESCRIPTOR_HANDLE backBufferDescriptor;
    DxGetBackBuffer(&backBuffer, &backBufferDescriptor);
    D3D12_RESOURCE_BARRIER barrier = {
        .Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION,
        .Transition.pResource = backBuffer,
        .Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT,
        .Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET };
    cmdList->vt->ResourceBarrier(cmdList, 1, &barrier);

    F32 clearColor[] = { 0.0f, 0.2f, 0.4f, 1.0f };
    cmdList->vt->OMSetRenderTargets(cmdList, 1, &backBufferDescriptor, FALSE, &Dx.depthBufferDescriptor);
    cmdList->vt->ClearRenderTargetView(cmdList, backBufferDescriptor, clearColor, 0, NULL);
    cmdList->vt->ClearDepthStencilView(cmdList, Dx.depthBufferDescriptor, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, NULL);

    cmdList->vt->SetPipelineState(cmdList, G.pipelineState);
    cmdList->vt->SetGraphicsRootSignature(cmdList, G.rootSignature);
    cmdList->vt->IASetPrimitiveTopology(cmdList, D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    cmdList->vt->DrawInstanced(cmdList, 3, 1, 0, 0);

    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
    barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
    cmdList->vt->ResourceBarrier(cmdList, 1, &barrier);

    cmdList->vt->Close(cmdList);

    Dx.cmdQueue->vt->ExecuteCommandLists(Dx.cmdQueue, 1, (ID3D12CommandList **)&cmdList);
}

static void Init(void)
{
    /* pso */ {
        U32 vsSize, psSize;
        void *vsCode = LibLoadFile("data/0.vs.cso", &vsSize);
        void *psCode = LibLoadFile("data/0.ps.cso", &psSize);

        D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc = {
            .VS = { vsCode, vsSize },
            .PS = { psCode, psSize },
            .RasterizerState.FillMode = D3D12_FILL_MODE_SOLID,
            .RasterizerState.CullMode = D3D12_CULL_MODE_NONE,
            .BlendState.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL,
            .SampleMask = 0xffffffff,
            .PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE,
            .NumRenderTargets = 1,
            .RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM,
            .SampleDesc.Count = 1 };
        VHR(Dx.device->vt->CreateGraphicsPipelineState(Dx.device, &psoDesc, &IID_ID3D12PipelineState, &G.pipelineState));
        VHR(Dx.device->vt->CreateRootSignature(Dx.device, 0, vsCode, vsSize, &IID_ID3D12RootSignature, &G.rootSignature));

        LibFree(vsCode);
        LibFree(psCode);
    }
    Dx.cmdList->vt->Close(Dx.cmdList);
}

void Start(void)
{
    G.viewportWidth = 1920;
    G.viewportHeight = 1080;
    G.demoName = "test01";

    LibLoadFunctions();
    SetProcessDPIAware();

    void *window = LibCreateWindow(G.demoName, G.viewportWidth, G.viewportHeight);
    DxInit(window);
    Init();

    for (;;) {
        MSG message = { 0 };
        if (PeekMessage(&message, 0, 0, 0, PM_REMOVE)) {
            DispatchMessage(&message);
            if (message.message == WM_QUIT)
                break;
        } else {
            F64 frameTime;
            F32 frameDeltaTime;
            LibUpdateFrameStats(window, G.demoName, &frameTime, &frameDeltaTime);
            Draw();
            DxPresent();
        }
    }

    ExitProcess(0);
}
//-------------------------------------------------------------------------------------------------
